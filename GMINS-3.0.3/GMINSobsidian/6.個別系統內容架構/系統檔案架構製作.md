# GMINS ç³»çµ±æª”æ¡ˆæ¶æ§‹è£½ä½œæµç¨‹

## é–‹ç™¼é †åºå»ºè­°ï¼ˆç”±åº•å±¤åˆ°ä¸Šå±¤ï¼‰

### éšæ®µä¸€ï¼šåŸºç¤è³‡æ–™çµæ§‹ (Foundation)
```
å„ªå…ˆé †åºï¼šæœ€é«˜ | ä¾è³´ï¼šç„¡
ç›®æ¨™ï¼šå»ºç«‹æ‰€æœ‰æ¨¡çµ„å…±ç”¨çš„è³‡æ–™å‹åˆ¥å’ŒåŸºæœ¬å·¥å…·
```

**1.1 å»ºç«‹åŸºæœ¬è³‡æ–™å‹åˆ¥**
- `src/data/data_types.h` - å®šç¾© IMUData, GNSSData, NavigationStateèˆ‡å€‹æ¨¡çµ„ä½¿ç”¨çš„è³‡æ–™æ¨£å¼
- `src/util/log.h` - å»ºç«‹æ¨¡çµ„åŒ– debug ç³»çµ±
- `src/util/math_utils.h` - åŸºæœ¬æ•¸å­¸å·¥å…·å‡½æ•¸

**1.2 å»ºç«‹é©é…å±¤éª¨æ¶ (é—œéµæ¶æ§‹æ±ºç­–) ğŸ¯**
- `src/adapter/imu_adapter.h` - IMU æ•¸æ“šé©é…ä»‹é¢
- `src/adapter/gnss_adapter.h` - GNSS æ•¸æ“šé©é…ä»‹é¢
- `src/adapter/navigation_adapter.h` - å°èˆªç‹€æ…‹é©é…ä»‹é¢
- `src/adapter/coord_adapter.h` - åº§æ¨™è½‰æ›é©é…ä»‹é¢

**ç‚ºä»€éº¼å¾é€™è£¡é–‹å§‹ï¼š**
- æ‰€æœ‰å…¶ä»–æ¨¡çµ„éƒ½æœƒç”¨åˆ°é€™äº›è³‡æ–™çµæ§‹
- **é©é…å±¤ç¢ºä¿æ•¸æ“šçµæ§‹èˆ‡æ•¸å­¸è¨ˆç®—è§£è€¦**
- ç„¡å¤–éƒ¨ä¾è³´ï¼Œå¯ä»¥ç¨ç«‹é–‹ç™¼å’Œæ¸¬è©¦
- å®šç¾©å¥½è³‡æ–™æ ¼å¼å¾Œï¼Œå…¶ä»–æ¨¡çµ„çš„ä»‹é¢å°±æ¸…æ¥šäº†
- **å¾ŒçºŒæ¨¡çµ„å…¨éƒ¨é€šéé©é…å±¤å­˜å–æ•¸æ“šï¼Œé¿å…ç›´æ¥è€¦åˆ**

### éšæ®µäºŒï¼šç¡¬é«”æŠ½è±¡å±¤ (HAL)
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šåŸºç¤è³‡æ–™çµæ§‹
ç›®æ¨™ï¼šæŠ½è±¡åŒ–ç¡¬é«”ç›¸é—œåŠŸèƒ½ï¼Œè®“ä¸Šå±¤æ¨¡çµ„ä¸ä¾è³´ç‰¹å®šç¡¬é«”
```

**2.1 UART ä»‹é¢æŠ½è±¡**
- `src/hal/board_support.h` - å®šç¾©è…³ä½å’Œä¸²å£å°æ‡‰
- `src/comm/uart_interface.h` - UART æŠ½è±¡ä»‹é¢
- `src/comm/uart_interface_arduino.cpp` - Arduino å¯¦ä½œ

**ç‚ºä»€éº¼é€™æ™‚å€™åšï¼š**
- é€šè¨Šæ¨¡çµ„éœ€è¦ UART ä»‹é¢
- æŠ½è±¡åŒ–å¾Œå¯ä»¥è¼•é¬†æ›æ¿æˆ–æ¨¡æ“¬æ¸¬è©¦

### ğŸ“‹ éšæ®µäºŒï¼šç¡¬é«”æŠ½è±¡å±¤è©³ç´°è¨­è¨ˆ

#### 2.1.1 UART ä»‹é¢æŠ½è±¡è¨­è¨ˆ

**æ ¸å¿ƒè¨­è¨ˆåŸå‰‡**
- **å¹³å°ç„¡é—œæ€§**ï¼šä¸Šå±¤ä»£ç¢¼ä¸ä¾è³´ç‰¹å®šç¡¬é«”å¯¦ç¾
- **æ•ˆèƒ½å„ªåŒ–**ï¼šéé˜»å¡å¼ I/Oï¼Œæ”¯æ´æ™‚é–“é ç®—æ§åˆ¶
- **éŒ¯èª¤è™•ç†**ï¼šå®Œæ•´çš„éŒ¯èª¤ç‹€æ…‹å’Œæ¢å¾©æ©Ÿåˆ¶
- **è¨˜æ†¶é«”å®‰å…¨**ï¼šå›ºå®šå¤§å°ç·©è¡å€ï¼Œé¿å…å‹•æ…‹åˆ†é…

**ä»‹é¢å±¤ç´šçµæ§‹**
```cpp
// src/comm/uart_interface.h - æ ¸å¿ƒæŠ½è±¡ä»‹é¢
class IUARTInterface {
public:
    virtual ~IUARTInterface() = default;
    
    // åŸºæœ¬æ§åˆ¶ä»‹é¢
    virtual bool initialize(uint32_t baud_rate) = 0;
    virtual void shutdown() = 0;
    virtual bool isReady() const = 0;
    
    // éé˜»å¡ I/O ä»‹é¢
    virtual size_t available() const = 0;
    virtual size_t write(const uint8_t* data, size_t length) = 0;
    virtual size_t read(uint8_t* buffer, size_t max_length) = 0;
    virtual size_t readLine(char* buffer, size_t max_length, char delimiter = '\n') = 0;
    
    // é€²éšåŠŸèƒ½
    virtual bool flush(uint32_t timeout_ms = 1000) = 0;
    virtual void clearBuffer() = 0;
    virtual UARTStatistics getStatistics() const = 0;
    virtual UARTErrorState getErrorState() const = 0;
    
    // æ™‚é–“é ç®—æ§åˆ¶
    virtual size_t processWithBudget(uint32_t budget_us) = 0;
};

// UART çµ±è¨ˆå’ŒéŒ¯èª¤ç‹€æ…‹çµæ§‹
struct UARTStatistics {
    uint32_t bytes_sent;
    uint32_t bytes_received;
    uint32_t packets_sent;
    uint32_t packets_received;
    uint32_t error_count;
    uint32_t timeout_count;
    uint32_t buffer_overflow_count;
    float average_throughput_bps;
};

struct UARTErrorState {
    bool buffer_overflow;
    bool frame_error;
    bool parity_error;
    bool timeout_error;
    uint32_t last_error_timestamp;
    uint32_t consecutive_errors;
};
```

#### 2.1.2 Arduino å¹³å°å¯¦ä½œ

**åŸºæ–¼ç¾æœ‰æ¶æ§‹çš„å„ªåŒ–å¯¦ç¾**
```cpp
// src/comm/uart_interface_arduino.cpp - Arduino ç‰¹å®šå¯¦ä½œ
class ArduinoUARTInterface : public IUARTInterface {
public:
    explicit ArduinoUARTInterface(HardwareSerial& serial);
    
    // å¯¦ç¾åŸºæœ¬æ§åˆ¶ä»‹é¢
    bool initialize(uint32_t baud_rate) override;
    void shutdown() override;
    bool isReady() const override { return serial_.availableForWrite() > 0; }
    
    // å¯¦ç¾ I/O ä»‹é¢ï¼ˆåƒè€ƒ XsensUart å’Œ uartRT è¨­è¨ˆï¼‰
    size_t available() const override { return serial_.available(); }
    size_t write(const uint8_t* data, size_t length) override;
    size_t read(uint8_t* buffer, size_t max_length) override;
    size_t readLine(char* buffer, size_t max_length, char delimiter = '\n') override;
    
    // å¯¦ç¾é€²éšåŠŸèƒ½
    bool flush(uint32_t timeout_ms = 1000) override;
    void clearBuffer() override;
    UARTStatistics getStatistics() const override { return stats_; }
    UARTErrorState getErrorState() const override { return error_state_; }
    
    // æ™‚é–“é ç®—æ§åˆ¶å¯¦ç¾
    size_t processWithBudget(uint32_t budget_us) override;

private:
    HardwareSerial& serial_;
    UARTStatistics stats_;
    UARTErrorState error_state_;
    
    // å›ºå®šå¤§å°ç·©è¡å€ï¼ˆé¿å…å‹•æ…‹åˆ†é…ï¼‰
    static constexpr size_t BUFFER_SIZE = 512;
    uint8_t read_buffer_[BUFFER_SIZE];
    uint8_t write_buffer_[BUFFER_SIZE];
    
    // çµ±è¨ˆæ›´æ–°æ–¹æ³•
    void updateStatistics(size_t bytes_processed, bool is_read);
    void handleError(UARTError error_type);
};
```

#### 2.1.3 æ¿ç´šæ”¯æ´åŒ…è£è¨­è¨ˆ

**ç¡¬é«”é…ç½®æŠ½è±¡åŒ–**
```cpp
// src/hal/board_support.h - æ¿ç´šç¡¬é«”å®šç¾©
namespace hal {
    // UART è³‡æºå®šç¾©ï¼ˆåŸºæ–¼ç¾æœ‰ myUART.h è¨­è¨ˆï¼‰
    enum class UARTChannel {
        DEBUG = 0,      // Serial  - USB debug
        GNSS = 1,       // Serial1 - GNSS æ¥æ”¶å™¨
        IMU = 2,        // Serial2 - IMU/Xsens
        MAVLINK = 3,    // Serial3 - MAVLink è¼¸å‡º
        AUX = 4         // Serial4 - è¼”åŠ©é€šè¨Š
    };
    
    // ç¡¬é«”é…ç½®çµæ§‹
    struct UARTConfig {
        uint32_t default_baud_rate;
        uint8_t rx_pin;
        uint8_t tx_pin;
        bool enabled;
        uint16_t buffer_size;
        const char* description;
    };
    
    // æ¿ç´šé…ç½®è¡¨ï¼ˆå¯ç·¨è­¯æœŸé…ç½®ï¼‰
    extern const UARTConfig UART_CONFIGS[];
    extern const size_t UART_COUNT;
    
    // ç¡¬é«”åˆå§‹åŒ–ä»‹é¢
    void initUARTPins();
    void initUARTPeripherals();
    HardwareSerial& getUARTSerial(UARTChannel channel);
    
    // éŒ¯èª¤è™•ç†
    void handleUARTError(UARTChannel channel, UARTError error);
}

// å¯¦éš›ç¡¬é«”é…ç½®ï¼ˆåŸºæ–¼ç¾æœ‰ myUART.hï¼‰
const UARTConfig hal::UART_CONFIGS[] = {
    {115200, 0,  0,  true,  512, "USB Debug"},        // DEBUG
    {460800, 23, 22, true,  1024, "GNSS Receiver"},   // GNSS (å„ªåŒ–æ³¢ç‰¹ç‡)
    {115200, 25, 24, true,  1024, "Xsens IMU"},       // IMU
    {115200, 13, 8,  true,  512, "MAVLink Output"},   // MAVLINK
    {115200, 10, 9,  true,  256, "Auxiliary"}         // AUX
};
```

#### 2.1.4 å¤šé€šé“ç®¡ç†å™¨

**çµ±ä¸€çš„é€šé“ç®¡ç†**
```cpp
// src/comm/uart_channel_manager.h - å¤šé€šé“ç®¡ç†
class UARTChannelManager {
public:
    bool initialize();
    void shutdown();
    
    // é€šé“å­˜å–ä»‹é¢
    IUARTInterface* getChannel(hal::UARTChannel channel);
    bool isChannelReady(hal::UARTChannel channel) const;
    
    // æ‰¹æ¬¡æ“ä½œ
    void processAllChannels(uint32_t total_budget_us);
    void flushAllChannels(uint32_t timeout_ms = 1000);
    void clearAllBuffers();
    
    // çµ±è¨ˆå’Œç›£æ§
    UARTChannelStatistics getChannelStatistics(hal::UARTChannel channel) const;
    SystemUARTHealth getSystemHealth() const;
    
private:
    std::array<std::unique_ptr<IUARTInterface>, static_cast<size_t>(hal::UARTChannel::AUX) + 1> channels_;
    UARTChannelStatistics channel_stats_[5];
    
    void distributeTimeBudget(uint32_t total_budget_us, uint32_t* budgets);
};

struct SystemUARTHealth {
    bool all_channels_ready;
    uint32_t total_throughput_bps;
    uint32_t total_error_count;
    float average_cpu_usage_percent;
    uint32_t longest_processing_time_us;
};
```

#### 2.1.5 å”è­°è§£æå™¨æ•´åˆä»‹é¢

**èˆ‡ç¾æœ‰ XsensUart å’Œ uartRT æ•´åˆ**
```cpp
// src/comm/protocol_parser_adapter.h - å”è­°è§£æå™¨é©é…
template<typename ProtocolParser>
class ProtocolParserAdapter {
public:
    explicit ProtocolParserAdapter(IUARTInterface* uart_interface, ProtocolParser& parser)
        : uart_(uart_interface), parser_(parser) {}
    
    // éé˜»å¡è§£æè™•ç†
    bool processIncomingData(uint32_t budget_us);
    
    // è§£æç‹€æ…‹æŸ¥è©¢
    bool hasCompletePacket() const;
    size_t getPacketData(uint8_t* buffer, size_t max_length);
    
    // çµ±è¨ˆè³‡è¨Š
    ParserStatistics getStatistics() const;

private:
    IUARTInterface* uart_;
    ProtocolParser& parser_;
    ParserStatistics stats_;
    
    static constexpr size_t PARSE_BUFFER_SIZE = 256;
    uint8_t parse_buffer_[PARSE_BUFFER_SIZE];
};

// ä½¿ç”¨ç¯„ä¾‹ï¼šæ•´åˆ XsensUart
using XsensAdapter = ProtocolParserAdapter<XsensUart>;
using NMEAAdapter = ProtocolParserAdapter<NMEAParser>;
```

#### 2.1.6 éŒ¯èª¤è™•ç†å’Œæ¢å¾©æ©Ÿåˆ¶

**å®Œæ•´çš„éŒ¯èª¤åˆ†é¡å’Œè‡ªå‹•æ¢å¾©**
```cpp
// src/comm/uart_error_handler.h - UART éŒ¯èª¤è™•ç†
class UARTErrorHandler {
public:
    void handleError(hal::UARTChannel channel, UARTError error);
    void updateErrorStatistics(hal::UARTChannel channel, const UARTErrorState& state);
    
    // è‡ªå‹•æ¢å¾©ç­–ç•¥
    bool attemptRecovery(hal::UARTChannel channel, UARTError error);
    void scheduleHealthCheck(hal::UARTChannel channel, uint32_t delay_ms);
    
    // éŒ¯èª¤å ±å‘Š
    ErrorReport generateReport() const;
    void logErrorDetails(hal::UARTChannel channel, const UARTErrorState& state);

private:
    struct ChannelErrorContext {
        uint32_t consecutive_errors;
        uint32_t last_error_time;
        uint32_t recovery_attempts;
        bool in_recovery_mode;
    };
    
    ChannelErrorContext channel_contexts_[5];
    
    bool executeRecoveryStrategy(hal::UARTChannel channel, RecoveryStrategy strategy);
    void resetChannel(hal::UARTChannel channel);
    void escalateError(hal::UARTChannel channel, UARTError error);
};
```

#### 2.1.7 æ•ˆèƒ½å„ªåŒ–å’Œæ™‚é–“é ç®—

**åŸºæ–¼ç¾æœ‰æ¶æ§‹çš„æ•ˆèƒ½æå‡**
```cpp
// src/comm/uart_performance.h - æ•ˆèƒ½å„ªåŒ–
class UARTPerformanceOptimizer {
public:
    struct PerformanceConfig {
        uint32_t max_processing_time_us;    // æœ€å¤§è™•ç†æ™‚é–“
        uint32_t batch_size;                // æ‰¹æ¬¡è™•ç†å¤§å°
        bool enable_dma;                    // å•Ÿç”¨ DMAï¼ˆå¦‚æœæ”¯æ´ï¼‰
        uint8_t priority_weights[5];        // é€šé“å„ªå…ˆæ¬Šé‡
    };
    
    void configure(const PerformanceConfig& config);
    
    // æ™ºæ…§æ™‚é–“é ç®—åˆ†é…
    void distributeBudget(uint32_t total_budget_us, uint32_t* channel_budgets);
    
    // æ•ˆèƒ½ç›£æ§
    PerformanceMetrics getMetrics() const;
    void logPerformanceReport();

private:
    PerformanceConfig config_;
    PerformanceMetrics metrics_;
    
    void updateMetrics(hal::UARTChannel channel, uint32_t processing_time_us);
    void adjustPriorities();
};

struct PerformanceMetrics {
    float cpu_utilization_percent;
    uint32_t max_processing_time_us;
    uint32_t average_processing_time_us;
    uint32_t throughput_bytes_per_second[5];
    uint32_t buffer_utilization_percent[5];
};
```

#### 2.1.8 æ¸¬è©¦å’Œé©—è­‰ä»‹é¢

**å®Œæ•´çš„æ¸¬è©¦æ”¯æ´**
```cpp
// src/comm/uart_test_interface.h - æ¸¬è©¦ä»‹é¢
class UARTTestInterface {
public:
    // ç¡¬é«”åœ¨ç’°æ¸¬è©¦
    bool runHardwareLoopbackTest(hal::UARTChannel channel);
    bool runCommunicationTest(hal::UARTChannel tx_channel, hal::UARTChannel rx_channel);
    
    // æ•ˆèƒ½åŸºæº–æ¸¬è©¦
    PerformanceBenchmark runThroughputTest(hal::UARTChannel channel, uint32_t duration_ms);
    LatencyBenchmark runLatencyTest(hal::UARTChannel channel, uint32_t iterations);
    
    // ç©©å®šæ€§æ¸¬è©¦
    bool runStabilityTest(hal::UARTChannel channel, uint32_t duration_hours);
    bool runStressTest(uint32_t max_load_percent, uint32_t duration_minutes);
    
    // æ¨¡æ“¬æ¸¬è©¦
    void simulateErrorCondition(hal::UARTChannel channel, UARTError error);
    void simulateHighLoad(uint32_t load_percent);
    
    // æ¸¬è©¦å ±å‘Š
    TestReport generateReport() const;

private:
    TestStatistics test_stats_;
    TestConfiguration test_config_;
    
    bool verifyDataIntegrity(const uint8_t* sent_data, const uint8_t* received_data, size_t length);
    void recordTestMetric(const std::string& metric_name, double value);
};
```

#### 2.1.9 æ•´åˆåˆ°ç³»çµ±æ¶æ§‹

**èˆ‡å…¶ä»–æ¨¡çµ„çš„ä»‹é¢**
```cpp
// åœ¨ CommunicationManager ä¸­ä½¿ç”¨
class CommunicationManager {
public:
    bool initialize() {
        // åˆå§‹åŒ– UART é€šé“ç®¡ç†å™¨
        if (!uart_manager_.initialize()) {
            LOG_ERR("COMM", "UART é€šé“åˆå§‹åŒ–å¤±æ•—");
            return false;
        }
        
        // è¨­å®šå”è­°è§£æå™¨
        gnss_parser_ = std::make_unique<XsensAdapter>(
            uart_manager_.getChannel(hal::UARTChannel::GNSS), 
            xsens_uart_
        );
        
        return true;
    }
    
    void processIncomingData(uint32_t budget_us) {
        // ä½¿ç”¨æ™‚é–“é ç®—è™•ç†æ‰€æœ‰é€šé“
        uart_manager_.processAllChannels(budget_us);
        
        // è™•ç†è§£æå®Œæˆçš„æ•¸æ“š
        processGNSSData();
        processIMUData();
    }

private:
    UARTChannelManager uart_manager_;
    std::unique_ptr<XsensAdapter> gnss_parser_;
    std::unique_ptr<NMEAAdapter> nmea_parser_;
    XsensUart xsens_uart_;
};
```

### éšæ®µä¸‰ï¼šå¤šå”è­°è¼¸å‡ºç³»çµ± (Multi-Protocol Output System) ğŸ¯
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šè³‡æ–™çµæ§‹ + UARTä»‹é¢
ç›®æ¨™ï¼šæ”¯æ´å¤šç¨®è¼¸å‡ºæ¨¡å¼ï¼Œä¸‰ç¨®å°åŒ…äº’æ–¥ï¼Œå®‰å…¨æ¨¡å¼åˆ‡æ›
```

**3.1 å‚³è¼¸å±¤æŠ½è±¡ + å”è­°ä»‹é¢è¨­è¨ˆ**
- `src/transport/ITransport.h` - å‚³è¼¸å±¤æŠ½è±¡ (UART/UDP/USB)
- `src/protocol/IProtocol.h` - å”è­°æŠ½è±¡ä»‹é¢
- `src/protocol/IMode.h` - é‹è¡Œæ¨¡å¼ç­–ç•¥ä»‹é¢

**3.2 ä¸‰ç¨®å”è­°å¯¦ç¾ï¼ˆäº’æ–¥è¼¸å‡ºï¼‰**
- `src/protocol/MAVLinkProtocol.h` - Pixhawk MAVLink v2.0 å°åŒ…
- `src/protocol/AR1AFCProtocol.h` - è‡ªå®¶ AR-1A-FC æ ¼å¼ (52å­—ç¯€)
- `src/protocol/MTINativeProtocol.h` - MTI XBUS åŸç”Ÿé€å‚³

**3.3 ä¸²å£ç®¡ç†èˆ‡æ¨¡å¼åˆ‡æ›**
- `src/comm/TxMultiplexer.h` - ä¸²å£æ“æœ‰æ¬Šç®¡ç†å™¨
- `src/core/SystemController.h` - æ¨¡å¼åˆ‡æ›æ§åˆ¶å™¨

**ç‚ºä»€éº¼é€™å€‹è¨­è¨ˆï¼š**
- **åˆ†å±¤æ¶æ§‹**ï¼šITransport â†’ IProtocol â†’ IMode â†’ SystemController
- **äº’æ–¥ä¿è­‰**ï¼šåŒä¸€æ™‚é–“åªæœ‰ä¸€ç¨®å”è­°èƒ½è¼¸å‡ºåˆ°ä¸²å£
- **å®‰å…¨åˆ‡æ›**ï¼šåœæ­¢ç•¶å‰è¼¸å‡º â†’ flush ä¸²å£ â†’ æ¸…ç©º RX buffer â†’ é‡å»ºå”è­°ç‰©ä»¶ â†’ ç™¼é€æ¨¡å¼æ¨™é ­
- **ç·¨è­¯æœŸæª¢æŸ¥**ï¼š`static_assert` ç¢ºä¿å°åŒ…å¤§å°ç¬¦åˆè¦ç¯„ï¼ˆMAVLink â‰¤ 255 bytesï¼‰

### éšæ®µå››ï¼šç³»çµ±é…ç½®èˆ‡æ¨¡å¼ç®¡ç† (System Configuration & Mode Management)  
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šå¤šå”è­°è¼¸å‡ºç³»çµ±
ç›®æ¨™ï¼šæ•´åˆé…ç½®ç³»çµ±ï¼Œæ”¯æ´å¤šç¨®åˆ‡æ›æ–¹å¼ï¼ˆconfig.tomlã€ç·¨è­¯æ——æ¨™ã€é‹è¡Œæ™‚æŒ‡ä»¤ï¼‰
```

**4.1 é…ç½®ç³»çµ±**
- `src/config/system_config.h` - é…ç½®æ–‡ä»¶è§£æå™¨ (config.toml)
- `src/config/compile_flags.h` - ç·¨è­¯æ™‚æœŸæ——æ¨™å®šç¾©
- `src/config/runtime_commands.h` - é‹è¡Œæ™‚æŒ‡ä»¤è™•ç†å™¨

**4.2 æ¨¡å¼ç­–ç•¥å¯¦ç¾**
- `src/modes/PixhawkMode.h` - Pixhawk MAVLink è¼¸å‡ºæ¨¡å¼
- `src/modes/AR1AFCMode.h` - AR-1A-FC è‡ªå®¶æ ¼å¼è¼¸å‡ºæ¨¡å¼  
- `src/modes/MTIMode.h` - MTI åŸç”Ÿé€å‚³æ¨¡å¼

**4.3 ç³»çµ±æ§åˆ¶å™¨æ•´åˆ**
- `src/core/SystemController.h/.cpp` - çµ±ä¸€æ§åˆ¶æ‰€æœ‰æ¨¡å¼åˆ‡æ›
- `src/core/ModeManager.h/.cpp` - æ¨¡å¼ç”Ÿå‘½é€±æœŸç®¡ç†

**4.4 é€šè¨Šç®¡ç†å™¨å‡ç´š**
- `src/comm/communication_manager.h/.cpp` - æ•´åˆå¤šå”è­°è¼¸å‡ºæ”¯æ´

### éšæ®µäº”ï¼šShift æ ¡æ­£ç³»çµ± (Critical Calibration)
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šé€šè¨Šç®¡ç†å™¨ + æ•¸å­¸å·¥å…· + é©é…å±¤
ç›®æ¨™ï¼šå¯¦ç¾ GNSS èˆªå‘èˆ‡ IMU åèˆªè§’çš„å‹•æ…‹æ ¡æ­£ç³»çµ±
```

**5.1 Shift æ ¡æ­£æ ¸å¿ƒæ¨¡çµ„**
- `src/fusion/shift_calibrator.h/.cpp` - Shift æ ¡æ­£ä¸»æ§åˆ¶å™¨
- `src/fusion/heading_alignment.h/.cpp` - èˆªå‘å°é½Šæ¼”ç®—æ³•
- `src/fusion/calibration_manager.h/.cpp` - æ ¡æ­£æµç¨‹ç®¡ç†

**5.2 é©é…å±¤å¯¦æˆ°æ‡‰ç”¨ ğŸ¯**
- **é‡æ§‹æ‰€æœ‰æ•¸æ“šå­˜å–ç‚ºé©é…å±¤èª¿ç”¨**
- `IMUAdapter::extractEulerAngles(imu_data, roll, pitch, yaw)` - å–å¾— IMU yaw
- `GNSSAdapter::getHeading(gnss_data, heading, accuracy)` - å–å¾— GNSS heading
- `NavigationAdapter::applyYawShiftToQuat(nav_state, shift_offset)` - æ‡‰ç”¨ yaw shift

**ç‚ºä»€éº¼é€™å€‹éšæ®µå¾ˆé‡è¦ï¼š**
- è§£æ±º GNSS èˆªå‘å’Œ IMU åèˆªè§’ä¹‹é–“çš„ç³»çµ±æ€§åå·®
- æä¾›åˆå§‹åŒ–æ ¡æ­£å’Œå‹•æ…‹æ ¡æ­£å…©ç¨®æ¨¡å¼
- æ”¯æ´ Fusion æ¨¡å¼ï¼ˆæ­æ‹‰è§’ï¼‰å’Œæ¨™æº–æ¨¡å¼ï¼ˆå››å…ƒæ•¸ï¼‰
- **é©é…å±¤åœ¨æ­¤éšæ®µæ­£å¼è½åœ°ä½¿ç”¨ï¼Œç‚ºèåˆå¼•æ“å¥ åŸº**
- æ˜¯æ„Ÿæ¸¬å™¨èåˆçš„é—œéµå‰ç½®æ­¥é©Ÿ

### éšæ®µå…­ï¼šèåˆæ¼”ç®—æ³• (Fusion Engine)
```
å„ªå…ˆé †åºï¼šä¸­é«˜ | ä¾è³´ï¼šShiftæ ¡æ­£ + æ•¸å­¸å·¥å…· + é©é…å±¤
ç›®æ¨™ï¼šå¯¦ç¾æ„Ÿæ¸¬å™¨èåˆæ ¸å¿ƒæ¼”ç®—æ³•
```

**6.1 EKF æ¿¾æ³¢å™¨**
- `src/fusion/ekf_position.h/.cpp` - ä½ç½®æ¿¾æ³¢å™¨
- `src/fusion/ekf_orientation.h/.cpp` - å§¿æ…‹æ¿¾æ³¢å™¨
- `src/fusion/fusion_engine.h/.cpp` - èåˆå¼•æ“ä¸»é«”

**6.2 é©é…å±¤æ“´å……èˆ‡å›ºåŒ– ğŸ¯**
- `IMUAdapter::getAccelVector(imu_data)` / `getGyroVector(imu_data)` - å‘é‡å­˜å–
- `NavigationAdapter::updateFromFusionOutput(nav_state, pos, vel, quat)` - èåˆçµæœæ›´æ–°
- `CoordAdapter::ned_to_enu()` / `euler_to_rotation_matrix()` - åº§æ¨™ç³»è½‰æ›çµ±ä¸€å‡ºå£
- **èåˆå¼•æ“åªé—œå¿ƒå‘é‡/çŸ©é™£/å››å…ƒæ•¸ï¼Œä¸ç¢°è³‡æ–™çµæ§‹æ¬„ä½**

### éšæ®µä¸ƒï¼šå®‰å…¨ç³»çµ±èˆ‡é‹è¡Œæ™‚æ§åˆ¶ (Safety Guardian & Runtime Control)
```
å„ªå…ˆé †åºï¼šä¸­ | ä¾è³´ï¼šæ‰€æœ‰ä¸Šè¿°æ¨¡çµ„
ç›®æ¨™ï¼šç›£æ§ç³»çµ±å¥åº·ã€éŒ¯èª¤è™•ç†ã€é‹è¡Œæ™‚æ¨¡å¼åˆ‡æ›æŒ‡ä»¤
```

**7.1 å®‰å…¨ç›£æ§**
- `src/safety/error_handler.h/.cpp` - éŒ¯èª¤è™•ç†æ©Ÿåˆ¶
- `src/safety/safety_guardian.h/.cpp` - å®‰å…¨ç›£æ§ä¸»é«”

**7.2 é‹è¡Œæ™‚æŒ‡ä»¤ä»‹é¢ ğŸ®**
- `src/ui/command_interface.h/.cpp` - æŒ‡ä»¤è§£æå™¨
- `src/ui/mode_switch_commands.h` - æ¨¡å¼åˆ‡æ›æŒ‡ä»¤è™•ç†

**7.3 æ”¯æ´çš„é‹è¡Œæ™‚æŒ‡ä»¤**
```bash
# æ¨¡å¼åˆ‡æ›æŒ‡ä»¤
set_mode mavlink      # åˆ‡æ›åˆ° MAVLink æ¨¡å¼
set_mode ar1afc       # åˆ‡æ›åˆ° AR-1A-FC æ¨¡å¼  
set_mode mti          # åˆ‡æ›åˆ° MTI åŸç”Ÿæ¨¡å¼

# ç‹€æ…‹æŸ¥è©¢æŒ‡ä»¤
show_mode            # é¡¯ç¤ºç•¶å‰æ¨¡å¼
show_protocols       # é¡¯ç¤ºæ‰€æœ‰å¯ç”¨å”è­°
show_transport       # é¡¯ç¤ºå‚³è¼¸å±¤ç‹€æ…‹

# æ¸¬è©¦æŒ‡ä»¤
test_protocol <type> # æ¸¬è©¦æŒ‡å®šå”è­°
flush_buffers       # æ‰‹å‹•æ¸…ç©ºç·©è¡å€
```

### éšæ®µå…«ï¼šç³»çµ±æ§åˆ¶å™¨ (System Controller)
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šæ‰€æœ‰æ¨¡çµ„
ç›®æ¨™ï¼šå”èª¿æ‰€æœ‰æ¨¡çµ„é‹ä½œ
```

**8.1 ç³»çµ±æ•´åˆ**
- `src/core/system_health.h/.cpp` - ç³»çµ±å¥åº·ç›£æ§
- `src/core/system_controller.h/.cpp` - ä¸»æ§åˆ¶å™¨
- `src/main.cpp` - ä¸»ç¨‹å¼å…¥å£

## æ¯éšæ®µçš„æ¸¬è©¦ç­–ç•¥

### éšæ®µæ¸¬è©¦æ–¹æ³•
1. **åŸºç¤æ¸¬è©¦** - å–®å…ƒæ¸¬è©¦è³‡æ–™çµæ§‹å’Œå·¥å…·å‡½æ•¸
2. **HALæ¸¬è©¦** - ç”¨ç°¡å–®çš„ä¸²å£æ”¶ç™¼æ¸¬è©¦
3. **å¤šå”è­°æ¸¬è©¦** - é©—è­‰ä¸‰ç¨®å”è­°äº’æ–¥æ€§èˆ‡åˆ‡æ›å®‰å…¨æ€§ ğŸ¯
4. **æ¨¡å¼åˆ‡æ›æ¸¬è©¦** - æ¸¬è©¦é‹è¡Œæ™‚æŒ‡ä»¤å’Œé…ç½®æ–‡ä»¶åˆ‡æ›
5. **å°åŒ…å®Œæ•´æ€§æ¸¬è©¦** - é©—è­‰å°åŒ…å¤§å°å’Œ CRC æ ¡é©—
6. **èåˆæ¸¬è©¦** - ç”¨æ¨¡æ“¬è³‡æ–™æ¸¬è©¦æ¼”ç®—æ³•
7. **æ•´åˆæ¸¬è©¦** - æ‰€æœ‰æ¨¡çµ„ä¸€èµ·é‹ä½œ

### ğŸ§ª å¤šå”è­°è¼¸å‡ºç³»çµ±å°ˆé …æ¸¬è©¦

**3.1 å”è­°äº’æ–¥æ€§é©—è­‰**
```cpp
// æ¸¬è©¦ï¼šåŒæ™‚åªèƒ½æœ‰ä¸€å€‹å”è­°è¼¸å‡º
void test_protocol_exclusivity() {
    SystemController controller;
    
    // å•Ÿå‹• MAVLink æ¨¡å¼
    controller.switchMode(ModeType::MAVLINK);
    assert(controller.getCurrentMode() == ModeType::MAVLINK);
    
    // åˆ‡æ›åˆ° AR-1A-FC - æ‡‰è©²è‡ªå‹•åœæ­¢ MAVLink
    controller.switchMode(ModeType::AR1AFC);
    assert(controller.getCurrentMode() == ModeType::AR1AFC);
    assert(!controller.isModeActive(ModeType::MAVLINK));
}
```

**3.2 å®‰å…¨åˆ‡æ›æµç¨‹æ¸¬è©¦**
```cpp
// æ¸¬è©¦ï¼šæ¨¡å¼åˆ‡æ›æ™‚çš„ç·©è¡å€æ¸…ç†
void test_safe_mode_switching() {
    UARTTransport transport(Serial1);
    SystemController controller(&transport);
    
    // 1. è¨­å®š MAVLink æ¨¡å¼ä¸¦ç™¼é€æ•¸æ“š
    controller.switchMode(ModeType::MAVLINK);
    controller.sendTestData();
    
    // 2. åˆ‡æ›æ¨¡å¼æ™‚æ‡‰è©²ï¼šåœæ­¢â†’flushâ†’æ¸…ç©ºâ†’é‡å»ºâ†’ç™¼é€æ¨™é ­
    controller.switchMode(ModeType::AR1AFC);
    
    // 3. é©—è­‰ç·©è¡å€å·²æ¸…ç©º
    assert(transport.available() == 0);
    
    // 4. é©—è­‰æ¨¡å¼æ¨™é ­å·²ç™¼é€
    assert(controller.isHeaderSent());
}
```

**3.3 å°åŒ…å¤§å°ç·¨è­¯æœŸæª¢æŸ¥**
```cpp
// ç·¨è­¯æœŸæª¢æŸ¥ï¼šMAVLink payload â‰¤ 255 bytes
static_assert(MAVLinkProtocol::MAX_PAYLOAD_SIZE <= 255, 
              "MAVLink å°åŒ…å¤§å°è¶…éè¦ç¯„");

// ç·¨è­¯æœŸæª¢æŸ¥ï¼šAR-1A-FC å›ºå®š 52 bytes
static_assert(sizeof(AR1AFCProtocol::AR1AFCPacket) == 52, 
              "AR-1A-FC å°åŒ…å¤§å°å¿…é ˆç‚º 52 å­—ç¯€");
```



## ğŸ¯ å¤šå”è­°è¼¸å‡ºç³»çµ±æ•´åˆç¸½çµ

### æ ¸å¿ƒè¨­è¨ˆåŸå‰‡
1. **åˆ†å±¤æ¶æ§‹**ï¼šITransport â†’ IProtocol â†’ IMode â†’ SystemController
2. **äº’æ–¥ä¿è­‰**ï¼šåŒä¸€æ™‚é–“åªæœ‰ä¸€ç¨®å”è­°èƒ½è¼¸å‡ºåˆ°ä¸²å£ï¼ˆä¸²å£å›ºå®šï¼‰
3. **å®‰å…¨åˆ‡æ›**ï¼šåœæ­¢ç•¶å‰æ¨¡å¼ â†’ flush ä¸²å£ â†’ æ¸…ç©º RX buffer â†’ é‡å»ºå”è­°ç‰©ä»¶ â†’ ç™¼é€æ¨¡å¼æ¨™é ­
4. **å¤šæ¨£åŒ–é…ç½®**ï¼šæ”¯æ´ config.tomlã€ç·¨è­¯æ——æ¨™ã€é‹è¡Œæ™‚æŒ‡ä»¤ä¸‰ç¨®åˆ‡æ›æ–¹å¼
5. **ç·¨è­¯æœŸæª¢æŸ¥**ï¼šstatic_assert ç¢ºä¿å°åŒ…å¤§å°ç¬¦åˆè¦ç¯„

### ä¸‰ç¨®å”è­°ç‰¹æ€§
| å”è­° | å°åŒ…å¤§å° | ç”¨é€” | ç‰¹é» |
|------|----------|------|------|
| MAVLink v2.0 | â‰¤ 255 bytes | Pixhawk é£›æ§ | æ¨™æº–èˆªç©ºå”è­° |
| AR-1A-FC | å›ºå®š 52 bytes | è‡ªå®¶ GUI | é«˜æ•ˆèƒ½å›ºå®šæ ¼å¼ |
| MTI Native | â‰¤ 512 bytes | XSENS é€å‚³ | ä¿æŒåŸå§‹æ•¸æ“šå®Œæ•´æ€§ |

### æ¨¡å¼åˆ‡æ›æŒ‡ä»¤
```bash
set_mode mavlink      # åˆ‡æ›åˆ° MAVLink æ¨¡å¼
set_mode ar1afc       # åˆ‡æ›åˆ° AR-1A-FC æ¨¡å¼  
set_mode mti          # åˆ‡æ›åˆ° MTI åŸç”Ÿæ¨¡å¼
show_mode            # é¡¯ç¤ºç•¶å‰æ¨¡å¼
```

## ğŸ¯ å®Œæ•´ç³»çµ±æ¶æ§‹è£œå¼·é …ç›®

### **A ç´šå„ªå…ˆ - æ ¸å¿ƒåŸºç¤è¨­æ–½è£œå¼·**

#### éšæ®µ 0.5ï¼šé…ç½®ç®¡ç†ç³»çµ±å®Œæ•´åŒ–
```
å„ªå…ˆé †åºï¼šæœ€é«˜ | ä¾è³´ï¼šåŸºç¤è³‡æ–™çµæ§‹
ç›®æ¨™ï¼šæä¾›å®Œæ•´çš„é…ç½®æ–‡ä»¶æ”¯æ´å’Œåƒæ•¸ç®¡ç†
```

**0.5.1 é…ç½®æ–‡ä»¶è§£æèˆ‡ç®¡ç†**
- `src/config/toml_parser.h/.cpp` - TOML æ ¼å¼é…ç½®æ–‡ä»¶è§£æå™¨
- `src/config/config_validator.h/.cpp` - é…ç½®åƒæ•¸é©—è­‰å™¨
- `src/config/config_manager.h/.cpp` - çµ±ä¸€é…ç½®ç®¡ç†ä»‹é¢
- `src/config/default_configs.h` - é è¨­é…ç½®æ¨¡æ¿

**0.5.2 é‹è¡Œæ™‚é…ç½®ç†±æ›´æ–°**
- `src/config/hot_reload.h/.cpp` - ç„¡éœ€é‡å•Ÿçš„é…ç½®æ›´æ–°
- `src/config/config_watcher.h/.cpp` - é…ç½®æ–‡ä»¶è®ŠåŒ–ç›£æ§
- `src/config/parameter_server.h/.cpp` - åƒæ•¸æœå‹™å™¨ï¼ˆé¡ä¼¼ ROSï¼‰

#### éšæ®µ 1.5ï¼šæŒä¹…åŒ–å­˜å„²ç³»çµ±
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šé…ç½®ç®¡ç†ç³»çµ±
ç›®æ¨™ï¼šæ”¯æ´æ ¡æ­£æ•¸æ“šã€é…ç½®å’Œæ—¥èªŒçš„æŒä¹…åŒ–å­˜å„²
```

**1.5.1 NVS å­˜å„²ç®¡ç†**
- `src/storage/nvs_manager.h/.cpp` - éæ®ç™¼æ€§å­˜å„²ç®¡ç†å™¨
- `src/storage/calibration_storage.h/.cpp` - æ ¡æ­£æ•¸æ“šå­˜å„²å°ˆç”¨æ¥å£
- `src/storage/config_storage.h/.cpp` - é…ç½®æ•¸æ“šå­˜å„²æ¥å£
- `src/storage/log_storage.h/.cpp` - æ—¥èªŒæ•¸æ“šå¾ªç’°å­˜å„²

**1.5.2 æ•¸æ“šå‚™ä»½èˆ‡æ¢å¾©**
- `src/storage/backup_manager.h/.cpp` - æ•¸æ“šå‚™ä»½ç®¡ç†å™¨
- `src/storage/factory_reset.h/.cpp` - å·¥å» é‡ç½®åŠŸèƒ½
- `src/storage/migration_manager.h/.cpp` - æ•¸æ“šç‰ˆæœ¬å‡ç´šé·ç§»

### **B ç´šå„ªå…ˆ - å“è³ªä¿è­‰ç³»çµ±**

#### éšæ®µ 2.5ï¼šæ•¸æ“šå“è³ªè©•ä¼°ç³»çµ±
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šé€šè¨Šç®¡ç†å™¨
ç›®æ¨™ï¼šå¯¦æ™‚ç›£æ§æ„Ÿæ¸¬å™¨æ•¸æ“šå“è³ªï¼Œæä¾›å¯é æ€§è©•ä¼°
```

**2.5.1 æ„Ÿæ¸¬å™¨æ•¸æ“šå“è³ªæª¢æŸ¥**
- `src/quality/data_validator.h/.cpp` - æ•¸æ“šæœ‰æ•ˆæ€§é©—è­‰å™¨
- `src/quality/gnss_quality_assessor.h/.cpp` - GNSS æ•¸æ“šå“è³ªè©•ä¼°
- `src/quality/imu_quality_assessor.h/.cpp` - IMU æ•¸æ“šå“è³ªè©•ä¼°
- `src/quality/quality_metrics.h` - å“è³ªæŒ‡æ¨™å®šç¾©

**2.5.2 ç•°å¸¸æª¢æ¸¬èˆ‡è™•ç†**
- `src/quality/outlier_detector.h/.cpp` - ç•°å¸¸å€¼æª¢æ¸¬å™¨
- `src/quality/signal_integrity.h/.cpp` - ä¿¡è™Ÿå®Œæ•´æ€§ç›£æ§
- `src/quality/data_fusion_quality.h/.cpp` - èåˆæ•¸æ“šå“è³ªè©•ä¼°

#### éšæ®µ 3.5ï¼šå¤šå”è­°æ¸¬è©¦é©—è­‰æ¡†æ¶
```
å„ªå…ˆé †åºï¼šé«˜ | ä¾è³´ï¼šå¤šå”è­°è¼¸å‡ºç³»çµ±
ç›®æ¨™ï¼šè‡ªå‹•åŒ–æ¸¬è©¦å”è­°åˆ‡æ›å’Œäº’æ–¥æ€§
```

**3.5.1 å”è­°æ¸¬è©¦åŸºç¤è¨­æ–½**
- `src/test/protocol_test_framework.h/.cpp` - å”è­°æ¸¬è©¦æ¡†æ¶
- `src/test/mock_receivers.h/.cpp` - æ¨¡æ“¬æ¥æ”¶å™¨ï¼ˆMAVLink/AR1AFC/MTIï¼‰
- `src/test/switching_safety_test.h/.cpp` - åˆ‡æ›å®‰å…¨æ€§æ¸¬è©¦
- `src/test/performance_benchmark.h/.cpp` - æ€§èƒ½åŸºæº–æ¸¬è©¦

**3.5.2 è‡ªå‹•åŒ–æ¸¬è©¦å¥—ä»¶**
- `src/test/integration_tests.h/.cpp` - é›†æˆæ¸¬è©¦å¥—ä»¶
- `src/test/stress_tests.h/.cpp` - å£“åŠ›æ¸¬è©¦ï¼ˆé•·æ™‚é–“é‹è¡Œï¼‰
- `src/test/regression_tests.h/.cpp` - å›æ­¸æ¸¬è©¦å¥—ä»¶

### **C ç´šå„ªå…ˆ - é€²éšåŠŸèƒ½**

#### éšæ®µ 4.5ï¼šèåˆæ¼”ç®—æ³•æ•¸å­¸åº«
```
å„ªå…ˆé †åºï¼šä¸­é«˜ | ä¾è³´ï¼šæ•¸æ“šå“è³ªè©•ä¼°ç³»çµ±
ç›®æ¨™ï¼šæä¾›å®Œæ•´çš„çŸ©é™£é‹ç®—å’Œ EKF å¯¦ç¾
```

**4.5.1 æ•¸å­¸åŸºç¤åº«**
- `src/math/matrix.h/.cpp` - çŸ©é™£é‹ç®—åº«ï¼ˆå›ºå®šå¤§å°ï¼Œé¿å…å‹•æ…‹åˆ†é…ï¼‰
- `src/math/quaternion.h/.cpp` - å››å…ƒæ•¸é‹ç®—åº«
- `src/math/statistics.h/.cpp` - çµ±è¨ˆå‡½æ•¸åº«
- `src/math/coordinate_transforms.h/.cpp` - åæ¨™è½‰æ›åº«

**4.5.2 EKF å…·é«”å¯¦ç¾**
- `src/fusion/ekf_state_models.h/.cpp` - EKF ç‹€æ…‹æ¨¡å‹å®šç¾©
- `src/fusion/prediction_models.h/.cpp` - é æ¸¬æ¨¡å‹å¯¦ç¾
- `src/fusion/measurement_models.h/.cpp` - è§€æ¸¬æ¨¡å‹å¯¦ç¾
- `src/fusion/covariance_tuning.h/.cpp` - å”æ–¹å·®çŸ©é™£èª¿æ•´

#### éšæ®µ 5.5ï¼šé«˜ç´šè¨ºæ–·èˆ‡ç›£æ§ç³»çµ±
```
å„ªå…ˆé †åºï¼šä¸­ | ä¾è³´ï¼šæ‰€æœ‰æ ¸å¿ƒæ¨¡çµ„
ç›®æ¨™ï¼šæä¾›å…¨é¢çš„ç³»çµ±ç›£æ§å’Œé ç¨‹è¨ºæ–·èƒ½åŠ›
```

**5.5.1 ç³»çµ±å¥åº·ç›£æ§**
- `src/diagnostics/health_monitor.h/.cpp` - ç³»çµ±å¥åº·ç›£æ§å™¨
- `src/diagnostics/performance_monitor.h/.cpp` - æ€§èƒ½ç›£æ§å™¨
- `src/diagnostics/resource_monitor.h/.cpp` - è³‡æºä½¿ç”¨ç›£æ§å™¨
- `src/diagnostics/predictive_maintenance.h/.cpp` - é æ¸¬æ€§ç¶­è­·

**5.5.2 é ç¨‹è¨ºæ–·ä»‹é¢**
- `src/diagnostics/remote_cli.h/.cpp` - é ç¨‹å‘½ä»¤è¡Œä»‹é¢
- `src/diagnostics/telemetry_reporter.h/.cpp` - é™æ¸¬æ•¸æ“šå ±å‘Šå™¨
- `src/diagnostics/alert_system.h/.cpp` - å‘Šè­¦ç³»çµ±
- `src/diagnostics/diagnostic_web_server.h/.cpp` - Web è¨ºæ–·ä»‹é¢

### **D ç´šå„ªå…ˆ - æœªä¾†æ“´å±•**

#### éšæ®µ 6.5ï¼šOTA æ›´æ–°ç³»çµ±
```
å„ªå…ˆé †åºï¼šä½ | ä¾è³´ï¼šæŒä¹…åŒ–å­˜å„²ç³»çµ±
ç›®æ¨™ï¼šæ”¯æ´å›ºä»¶ç„¡ç·šæ›´æ–°å’Œç‰ˆæœ¬ç®¡ç†
```

**6.5.1 OTA æ ¸å¿ƒåŠŸèƒ½**
- `src/ota/firmware_updater.h/.cpp` - å›ºä»¶æ›´æ–°å™¨
- `src/ota/version_manager.h/.cpp` - ç‰ˆæœ¬ç®¡ç†å™¨
- `src/ota/update_scheduler.h/.cpp` - æ›´æ–°æ’ç¨‹å™¨
- `src/ota/rollback_manager.h/.cpp` - å›æ»¾ç®¡ç†å™¨

**6.5.2 å®‰å…¨æ›´æ–°æ©Ÿåˆ¶**
- `src/ota/signature_validator.h/.cpp` - æ•¸ä½ç°½ç« é©—è­‰
- `src/ota/incremental_update.h/.cpp` - å¢é‡æ›´æ–°æ”¯æ´
- `src/ota/update_integrity_check.h/.cpp` - æ›´æ–°å®Œæ•´æ€§æª¢æŸ¥

## å»ºè­°çš„å¯¦ä½œé †åºï¼ˆé©é…å±¤æ•´åˆç‰ˆï¼‰

**æ›´æ–°å¾Œçš„å®Œæ•´å¯¦ä½œé †åºï¼š**

1. **éšæ®µä¸€ï¼šåŸºç¤è³‡æ–™çµæ§‹ + é©é…å±¤éª¨æ¶** - å®šç¾©å¥½æ‰€æœ‰è³‡æ–™çµæ§‹å’Œè½‰æ›ä»‹é¢ ğŸ¯
2. **éšæ®µ 0.5ï¼šé…ç½®ç®¡ç†ç³»çµ±** - æä¾›åƒæ•¸ç®¡ç†åŸºç¤è¨­æ–½ ğŸ†•
3. **éšæ®µäºŒï¼šHAL æŠ½è±¡å±¤** - å»ºç«‹ç¡¬é«”æŠ½è±¡
4. **éšæ®µ 1.5ï¼šæŒä¹…åŒ–å­˜å„²ç³»çµ±** - æ”¯æ´æ•¸æ“šæŒä¹…åŒ– ğŸ†•
5. **éšæ®µä¸‰ï¼šå¤šå”è­°è¼¸å‡ºç³»çµ±** - æ ¸å¿ƒç‰¹è‰²åŠŸèƒ½ ğŸ¯
6. **éšæ®µ 2.5ï¼šæ•¸æ“šå“è³ªè©•ä¼°ç³»çµ±** - ç¢ºä¿æ•¸æ“šå¯é æ€§ ğŸ†•
7. **éšæ®µ 3.5ï¼šå¤šå”è­°æ¸¬è©¦é©—è­‰æ¡†æ¶** - é©—è­‰æ ¸å¿ƒåŠŸèƒ½ ğŸ†•
8. **éšæ®µå››ï¼šé…ç½®èˆ‡æ¨¡å¼ç®¡ç†** - æ•´åˆæ§åˆ¶ç³»çµ±
9. **éšæ®µäº”ï¼šShift æ ¡æ­£ç³»çµ± + é©é…å±¤å¯¦æˆ°æ‡‰ç”¨** - é—œéµæ ¡æ­£åŠŸèƒ½ï¼Œé©é…å±¤è½åœ° ğŸ¯
10. **éšæ®µ 4.5ï¼šèåˆæ¼”ç®—æ³•æ•¸å­¸åº«** - æ•¸å­¸åŸºç¤å¯¦ç¾ ğŸ†•
11. **éšæ®µå…­ï¼šèåˆæ¼”ç®—æ³• + é©é…å±¤å›ºåŒ–** - æ ¸å¿ƒèåˆåŠŸèƒ½ï¼Œé©é…å±¤å®Œå–„ ğŸ¯
12. **éšæ®µä¸ƒï¼šå®‰å…¨ç³»çµ±èˆ‡é‹è¡Œæ™‚æ§åˆ¶** - å®‰å…¨ä¿éšœ
13. **éšæ®µ 5.5ï¼šé«˜ç´šè¨ºæ–·èˆ‡ç›£æ§ç³»çµ±** - ç³»çµ±ç›£æ§ ğŸ†•
14. **éšæ®µå…«ï¼šç³»çµ±æ§åˆ¶å™¨** - ç³»çµ±æ•´åˆ
15. **éšæ®µ 6.5ï¼šOTA æ›´æ–°ç³»çµ±** - æœªä¾†ç¶­è­·æ”¯æ´ ğŸ†•

## ğŸ¯ é©é…å±¤å¯¦æ–½ç­–ç•¥

### éšæ®µä¸€ï¼ˆæ”¶å°¾ï¼‰ï¼šå»ºç«‹é©é…å±¤æœ€å° API
**ç›®æ¨™ï¼šç¢ºä¿å¾ŒçºŒæ¨¡çµ„éƒ½ç”¨ä¸€è‡´çš„æ•¸æ“šå­˜å–ä»‹é¢**

```cpp
// æœ€å°å¯ç”¨ç‰ˆæœ¬ - åªéœ€è¦é€™äº›æ ¸å¿ƒå‡½æ•¸
namespace IMUAdapter {
    bool extractEulerAngles(const IMUData&, float&, float&, float&);
    Vector3f getAccelerationVector(const IMUData&);
    Vector3f getGyroVector(const IMUData&);
}

namespace GNSSAdapter {
    bool getHeading(const GNSSData&, float&, float&);
    float calculateShiftOffset(float gnss_heading, float imu_yaw);
}
```

### éšæ®µäº”ï¼ˆè½åœ°ï¼‰ï¼šShift æ ¡æ­£å…¨é¢ä½¿ç”¨é©é…å±¤
**ç›®æ¨™ï¼šåœ¨ shift_calibrator.* ä¸­å…¨é¢é‡æ§‹ç‚ºé©é…å±¤èª¿ç”¨**

### éšæ®µå…­ï¼ˆå›ºåŒ–ï¼‰ï¼šèåˆå¼•æ“é€šéé©é…å±¤æ“ä½œ
**ç›®æ¨™ï¼šEKF åªé€éé©é…å±¤å­˜å–å‘é‡ã€çŸ©é™£ã€å››å…ƒæ•¸**

**å®Œæ•´æ¶æ§‹çš„å¥½è™•ï¼š**
- æ—©æœŸå»ºç«‹å®Œæ•´çš„é…ç½®å’Œå­˜å„²åŸºç¤è¨­æ–½
- æ¯å€‹éšæ®µéƒ½æœ‰å°æ‡‰çš„å“è³ªä¿è­‰æ©Ÿåˆ¶
- æä¾›å®Œæ•´çš„æ¸¬è©¦é©—è­‰æ¡†æ¶
- ç³»çµ±å…·å‚™é•·æœŸç¶­è­·å’Œæ“´å±•èƒ½åŠ›
- ç¬¦åˆå·¥æ¥­ç´šç³»çµ±çš„é–‹ç™¼æ¨™æº–
- **æä¾›éˆæ´»ä¸”ç©©å®šçš„å¤šå”è­°è¼¸å‡ºé¸æ“‡**

## å¯¦æˆ°ç´šå‡ç´šæ”¹é€²ï¼ˆç©©å®šæ€§å¼·åŒ–ç‰ˆï¼‰

### ğŸ¯ æ ¸å¿ƒè¨­è¨ˆåŸå‰‡
- **è®“ GMINS.ino ä¿æŒè¶…è–„** - ç§»æ¤æ€§å’Œå¯æ¸¬è©¦æ€§æœ€å¤§åŒ–
- **éé˜»å¡å¼è™•ç†** - ä½¿ç”¨æ™‚é–“é ç®—è€Œé delay()
- **äº‹ä»¶é©…å‹•æ¶æ§‹** - å›èª¿æ©Ÿåˆ¶å–ä»£è¼ªè©¢æª¢æŸ¥
- **ç¡¬é«”æŠ½è±¡åŒ–** - æ‰€æœ‰ç¡¬é«”å·®ç•°é–åœ¨ HAL å±¤
- **å¯é‡æ¸¬é©—æ”¶** - æ¯éšæ®µéƒ½æœ‰å…·é«”æ•¸å€¼æ¨™æº–
- **çµ±ä¸€æ™‚é–“åŸºæº–** - å…¨ç³»çµ±ä½¿ç”¨ microseconds
- **é›¶å‹•æ…‹é…ç½®** - é¿å…è¨˜æ†¶é«”ç¢ç‰‡å’Œæ´©æ¼
- **å®Œæ•´éŒ¯èª¤ç­–ç•¥** - åˆ†é¡è™•ç†èˆ‡è‡ªå‹•æ¢å¾©

### ğŸ”§ ç³»çµ±ç©©å®šæ€§æ ¸å¿ƒæ”¹é€²

#### 1. çµ±ä¸€æ™‚é–“åŸºæº–èˆ‡å–®ä½ç³»çµ±
```cpp
// src/data/data_types.h - æ¨™æº–åŒ–æ™‚é–“å’Œå–®ä½
namespace StandardUnits {
    // æ™‚é–“ï¼šçµ±ä¸€ä½¿ç”¨ microsecondsï¼ˆå¾é–‹æ©Ÿèµ·ç®—ï¼‰
    using timestamp_us_t = uint64_t;
    
    // è§’åº¦ï¼šçµ±ä¸€ä½¿ç”¨å¼§åº¦ï¼ˆå…§éƒ¨è™•ç†ï¼‰
    using angle_rad_t = float;
    using angle_deg_t = float;  // åƒ…ç”¨æ–¼é¡¯ç¤ºå’Œè¼¸å…¥
    
    // é€Ÿåº¦ï¼šçµ±ä¸€ä½¿ç”¨ SI å–®ä½
    using velocity_mps_t = float;      // ç·šæ€§é€Ÿåº¦ m/s
    using angular_vel_rps_t = float;   // è§’é€Ÿåº¦ rad/s
    
    // åŠ é€Ÿåº¦ï¼šçµ±ä¸€ä½¿ç”¨ m/sÂ²
    using acceleration_mps2_t = float;
    
    // ä½ç½®ï¼šçµ±ä¸€ä½¿ç”¨ç±³ï¼ˆENUåæ¨™ç³»ï¼‰
    using position_m_t = float;
    
    // å–®ä½è½‰æ›å‡½æ•¸ï¼ˆåƒ…åœ¨é‚Šç•Œè™•ä½¿ç”¨ï¼‰
    constexpr float deg_to_rad(float deg) { return deg * 0.017453292519943295f; }
    constexpr float rad_to_deg(float rad) { return rad * 57.29577951308232f; }
    constexpr timestamp_us_t millis_to_us(uint32_t ms) { return ms * 1000ULL; }
}

// æ‰€æœ‰è³‡æ–™çµæ§‹ä½¿ç”¨æ¨™æº–åŒ–æ™‚é–“æˆ³
struct IMUData {
    StandardUnits::timestamp_us_t timestamp_us;  // çµ±ä¸€æ™‚é–“åŸºæº–
    StandardUnits::acceleration_mps2_t accel_x, accel_y, accel_z;
    StandardUnits::angular_vel_rps_t gyro_x, gyro_y, gyro_z;
    // ... å…¶ä»–æ¬„ä½
};
```

#### 2. çµ±ä¸€éŒ¯èª¤åˆ†é¡èˆ‡å¾©åŸç­–ç•¥
```cpp
// src/safety/error_classification.h
enum class ErrorCategory {
    COMMUNICATION,
    SENSOR_DATA,
    FUSION_ALGORITHM,
    HARDWARE_FAULT,
    SYSTEM_RESOURCE,
    TIMING_VIOLATION
};

enum class ErrorSeverity {
    INFO,       // è³‡è¨Šæ€§è¨Šæ¯
    WARNING,    // è­¦å‘Šä½†å¯ç¹¼çºŒ
    ERROR,      // éŒ¯èª¤éœ€è¦è™•ç†
    CRITICAL,   // åš´é‡éŒ¯èª¤
    FATAL       // è‡´å‘½éŒ¯èª¤
};

enum class RecoveryStrategy {
    IGNORE,          // å¿½ç•¥éŒ¯èª¤
    RETRY,           // é‡è©¦æ“ä½œ
    RESET_MODULE,    // é‡ç½®æ¨¡çµ„
    DEGRADE_MODE,    // é™ç´šæ“ä½œ
    SAFE_MODE,       // é€²å…¥å®‰å…¨æ¨¡å¼
    SYSTEM_RESTART   // ç³»çµ±é‡å•Ÿ
};

struct ErrorDescriptor {
    uint32_t error_code;
    ErrorCategory category;
    ErrorSeverity severity;
    RecoveryStrategy strategy;
    const char* description;
    uint32_t max_retry_count;
    uint32_t recovery_timeout_ms;
};
```

#### 3. æ™‚é–“é ç®—æ§åˆ¶ç³»çµ±
```cpp
// src/util/timing_budget.h
class TimingBudget {
public:
    explicit TimingBudget(uint32_t budget_us) : budget_us_(budget_us), start_time_(micros()) {}
    
    bool hasTimeRemaining() const { return getElapsedTime() < budget_us_; }
    uint32_t getRemainingTime() const { 
        uint32_t elapsed = getElapsedTime();
        return (elapsed < budget_us_) ? (budget_us_ - elapsed) : 0;
    }
    uint32_t getElapsedTime() const { return micros() - start_time_; }
    float getBudgetUsage() const { return (float)getElapsedTime() / budget_us_; }
    
    void logBudgetUsage(const char* module) const {
        uint32_t elapsed = getElapsedTime();
        if (elapsed > budget_us_) {
            LOG_WARN("TIMING", "%s è¶…æ™‚: %luus/%luus (%.1f%%)", 
                     module, elapsed, budget_us_, getBudgetUsage() * 100.0f);
        }
    }
    
private:
    uint32_t budget_us_;
    uint32_t start_time_;
};

// ä½¿ç”¨ç¯„ä¾‹
void CommunicationManager::processIncomingData(uint32_t budget_us) {
    TimingBudget budget(budget_us);
    
    while (budget.hasTimeRemaining() && hasDataToProcess()) {
        processNextPacket();
    }
    
    budget.logBudgetUsage("COMM");
}
```

#### 4. åš´æ ¼çš„ HAL é‚Šç•Œç®¡ç†
```cpp
// src/hal/board_support.h - ç¡¬é«”æŠ½è±¡é‚Šç•Œ
namespace hal {
    // ä¸²å£è³‡æºæŠ½è±¡
    extern HardwareSerial& SERIAL_GNSS;    // Serial1
    extern HardwareSerial& SERIAL_IMU;     // Serial2
    extern HardwareSerial& SERIAL_MAVLINK; // Serial3
    extern HardwareSerial& SERIAL_DEBUG;   // Serial (USB)
    
    // è…³ä½å®šç¾©æŠ½è±¡
    extern const int PIN_LED_STATUS;
    extern const int PIN_LED_ERROR;
    extern const int PIN_BUZZER;
    
    // åˆå§‹åŒ–å‡½æ•¸ï¼ˆéš”é›¢æ‰€æœ‰ç¡¬é«”è¨­å®šï¼‰
    void initPins();
    void initUarts();
    void initTimers();
    
    // æ™‚é–“æŠ½è±¡
    uint64_t getMicroseconds();
    uint32_t getMilliseconds();
}

// GMINS.ino ä¸­çµ•ä¸ç›´æ¥ä½¿ç”¨ Serial1/Serial2
// éŒ¯èª¤åšæ³•ï¼šSerial1.begin(38400)
// æ­£ç¢ºåšæ³•ï¼šhal::initUarts()
```

#### 5. é›¶å‹•æ…‹é…ç½®ç­–ç•¥
```cpp
// src/util/memory_policy.h - è¨˜æ†¶é«”ç®¡ç†ç­–ç•¥
class StaticBufferManager {
public:
    // ç·¨è­¯æ™‚åˆ†é…æ‰€æœ‰ç·©è¡å€
    static constexpr size_t UART_BUFFER_SIZE = 1024;
    static constexpr size_t NMEA_BUFFER_SIZE = 512;
    static constexpr size_t PACKET_BUFFER_SIZE = 256;
    
private:
    // éœæ…‹åˆ†é…ç·©è¡å€æ± 
    static uint8_t uart_buffers_[4][UART_BUFFER_SIZE];
    static char nmea_buffers_[4][NMEA_BUFFER_SIZE];
    static uint8_t packet_buffers_[10][PACKET_BUFFER_SIZE];
    
public:
    static uint8_t* getUARTBuffer(int channel);
    static char* getNMEABuffer(int channel);
    static uint8_t* getPacketBuffer();
    static void returnPacketBuffer(uint8_t* buffer);
};

// ä½¿ç”¨ RAII ç®¡ç†ç‰©ä»¶ç”Ÿå‘½é€±æœŸ
template<typename T>
class StaticPtr {
private:
    alignas(T) static char storage_[sizeof(T)];
    static bool initialized_;
    
public:
    static T& getInstance() {
        if (!initialized_) {
            new (storage_) T();
            initialized_ = true;
        }
        return reinterpret_cast<T&>(storage_);
    }
};

// é¿å… String é¡åˆ¥ï¼Œä½¿ç”¨å›ºå®šç·©è¡å€
class FixedString {
public:
    static constexpr size_t MAX_LENGTH = 64;
    
    FixedString() : length_(0) { buffer_[0] = '\0'; }
    explicit FixedString(const char* str) { assign(str); }
    
    void assign(const char* str);
    void append(const char* str);
    const char* c_str() const { return buffer_; }
    size_t length() const { return length_; }
    bool empty() const { return length_ == 0; }
    
private:
    char buffer_[MAX_LENGTH + 1];
    size_t length_;
};
```

#### 6. ç·šä¸Šè¨ºæ–·ç³»çµ±
```cpp
// src/util/diagnostic_cli.h - è¨ºæ–·å‘½ä»¤ä»‹é¢
class DiagnosticCLI {
public:
    void initialize();
    void processCommand();
    
private:
    struct Command {
        const char* name;
        void (*handler)(const char* args);
        const char* help;
    };
    
    static Command commands_[];
    static char command_buffer_[128];
    
    // è¨ºæ–·æŒ‡ä»¤è™•ç†å‡½æ•¸
    static void handleStatus(const char* args);
    static void handleCommStats(const char* args);
    static void handleMemInfo(const char* args);
    static void handleLogLevel(const char* args);
    static void handleResetComm(const char* args);
    static void handleSystemTest(const char* args);
    static void handleHelp(const char* args);
};

// ç³»çµ±å¥åº·å¿ƒè·³ç›£æ§
class HealthMonitor {
public:
    struct SystemMetrics {
        float cpu_usage_percent;
        uint32_t free_heap_bytes;
        uint32_t loop_frequency_hz;
        uint32_t uart_bytes_per_sec[4];
        uint32_t error_counts[6];  // æŒ‰éŒ¯èª¤é¡å‹åˆ†é¡
        uint32_t uptime_seconds;
    };
    
    void update();
    void printHealthReport() const;
    SystemMetrics getMetrics() const { return metrics_; }
    
private:
    SystemMetrics metrics_;
    uint32_t last_heartbeat_time_;
    uint32_t loop_count_;
    uint32_t last_loop_time_;
    
    void calculateCPUUsage();
    void updateUARTStatistics();
    void checkSystemHealth();
};

// GMINS.ino ä¸­çš„ä½¿ç”¨
DiagnosticCLI cli;
HealthMonitor health_monitor;

void loop() {
    // ... æ­£å¸¸ç³»çµ±é‚è¼¯ ...
    
    // è™•ç†è¨ºæ–·æŒ‡ä»¤
    if (Serial.available()) {
        cli.processCommand();
    }
    
    // å®šæœŸå¥åº·æª¢æŸ¥
    static uint32_t last_health_check = 0;
    if (millis() - last_health_check > 5000) {  // æ¯5ç§’
        health_monitor.update();
        health_monitor.printHealthReport();
        last_health_check = millis();
    }
}
```

### 1. çµ±ä¸€æ—¥èªŒ APIï¼ˆå±¤ç´š + æ¨¡çµ„æ¨™ç±¤ï¼‰
```cpp
// src/util/log.h - çµ±ä¸€æ ¼å¼
#define LOG_INFO(tag, fmt, ...)  Serial.printf("[I][%s] " fmt "\n", tag, ##__VA_ARGS__)
#define LOG_WARN(tag, fmt, ...)  Serial.printf("[W][%s] " fmt "\n", tag, ##__VA_ARGS__)
#define LOG_ERR(tag,  fmt, ...)  Serial.printf("[E][%s] " fmt "\n", tag, ##__VA_ARGS__)

// ä½¿ç”¨æ–¹å¼
LOG_INFO("SYSTEM", "åˆå§‹åŒ–å®Œæˆ");
LOG_INFO("GNSS", "æ”¶åˆ° %d é¡†è¡›æ˜Ÿ", satellite_count);
LOG_WARN("IMU", "é™€èºå„€åç§»éå¤§: %.3f", bias);
```

### 2. æ™‚é–“é ç®—æ§åˆ¶ï¼ˆé¿å…é˜»å¡ï¼‰
```cpp
// æ¯å€‹æ¨¡çµ„éƒ½æ¥å—æ™‚é–“é ç®—åƒæ•¸
void loop() {
  uint32_t loop_start = micros();
  uint32_t budget_us = 5000;  // æœ¬è¼ªæœ€å¤š 5ms
  
  comm_manager.processIncomingData(budget_us);
  fusion_engine.update(budget_us);
  safety_guardian.checkSystem(budget_us);
  
  uint32_t used = micros() - loop_start;
  if (used > budget_us) {
    LOG_WARN("TIMING", "é ç®—è¶…æ™‚: %lu/%lu us", used, budget_us);
  }
}
```

### 3. ç¡¬é«”æŠ½è±¡æ³¨å…¥ï¼ˆç§»æ¤æ€§ï¼‰
```cpp
// src/hal/board_support.h
namespace hal {
    extern HardwareSerial& SERIAL_GNSS;    // Serial1
    extern HardwareSerial& SERIAL_IMU;     // Serial2  
    extern HardwareSerial& SERIAL_MAVLINK; // Serial3
    
    void initPins();
    void initUarts();
}

// ä½¿ç”¨æ™‚ç›´æ¥æ³¨å…¥ç¡¬é«”åƒè€ƒ
ArduinoUARTInterface gnss{hal::SERIAL_GNSS};
ArduinoUARTInterface imu{hal::SERIAL_IMU};
```

### 4. é¿å…å‹•æ…‹è¨˜æ†¶é«”é…ç½®
```cpp
// å£çš„åšæ³•ï¼šå‹•æ…‹é…ç½®
ArduinoUARTInterface* gnss_uart = new ArduinoUARTInterface(1);

// å¥½çš„åšæ³•ï¼šéœæ…‹ç‰©ä»¶æˆ– RAII
ArduinoUARTInterface gnss_uart{hal::SERIAL_GNSS};
ArduinoUARTInterface imu_uart{hal::SERIAL_IMU};

// æˆ–ä½¿ç”¨å·¥å» æ¨¡å¼è¿”å›å¼•ç”¨
UARTInterface& gnss = hal::createGNSSInterface();
```

### 5. è¨ºæ–·æŒ‡ä»¤é€šé“ï¼ˆDebug CLIï¼‰
```cpp
// åœ¨ loop() ä¸­åŠ å…¥æŒ‡ä»¤è™•ç†
if (Serial.available()) {
  String cmd = Serial.readStringUntil('\n');
  handleDebugCommand(cmd);
}

// æŒ‡ä»¤ç¯„ä¾‹
void handleDebugCommand(const String& cmd) {
  if (cmd == "status") {
    printSystemStatus();
  } else if (cmd == "reset_comm") {
    comm_manager.reset();
  } else if (cmd.startsWith("log_level ")) {
    setLogLevel(cmd.substring(10).toInt());
  }
}
```

### 6. å°å‹ä»»å‹™æ’ç¨‹å™¨
```cpp
// src/util/task_scheduler.h
class TaskScheduler {
public:
    void every(uint32_t interval_ms, std::function<void()> task);
    void tick();
};

// GMINS.ino ä¸­ä½¿ç”¨
TaskScheduler scheduler;

void setup() {
  // ... åˆå§‹åŒ– ...
  
  scheduler.every(10,   []{ comm_manager.processIncomingData(2000); });
  scheduler.every(50,   []{ fusion_engine.update(3000); });
  scheduler.every(1000, []{ printHealthStatus(); });
  scheduler.every(100,  []{ safety_guardian.checkSystem(1000); });
}

void loop() {
  scheduler.tick();
  handleDebugCommands();
}
```

### 7. è³‡æ–™éŒ„æ”¾å·¥å…·éˆï¼ˆSIL/HIL æ¸¬è©¦ï¼‰
```cpp
// éšæ®µäºŒé–‹å§‹å°±èƒ½éŒ„è£½è³‡æ–™
class DataLogger {
public:
    void logRawUART(ChannelId channel, const uint8_t* data, size_t len);
    void logParsedGNSS(const GNSSData& data);
    void logParsedIMU(const IMUData& data);
};

// å¯ä»¥é›¢ç·šé‡æ’­æ¸¬è©¦èåˆæ¼”ç®—æ³•
class DataReplayer {
public:
    bool loadFromFile(const char* filename);
    bool getNextFrame(SensorDataPacket& packet);
};
```

## åˆ†éšæ®µ GMINS.ino å¯¦æˆ°ç‰ˆæœ¬

### éšæ®µä¸€ï¼šåŸºç¤è³‡æ–™çµæ§‹ + çµ±ä¸€æ—¥èªŒ
```cpp
#include "src/data/data_types.h"
#include "src/util/log.h"
#include "src/hal/board_support.h"

void setup() {
  hal::initPins();
  hal::initUarts();
  
  // ç·¨è­¯æ™‚æª¢æŸ¥è³‡æ–™çµæ§‹
  static_assert(sizeof(IMUData) <= 256, "IMUData éå¤§");
  static_assert(sizeof(GNSSData) <= 512, "GNSSData éå¤§");
  
  // æ¸¬è©¦è³‡æ–™çµæ§‹åˆå§‹åŒ–
  IMUData imu{};
  GNSSData gnss{};
  NavigationState nav{};
  
  LOG_INFO("SYSTEM", "éšæ®µä¸€ï¼šè³‡æ–™çµæ§‹é©—è­‰å®Œæˆ");
  LOG_INFO("SYSTEM", "IMU çµæ§‹å¤§å°: %d bytes", sizeof(IMUData));
  LOG_INFO("SYSTEM", "GNSS çµæ§‹å¤§å°: %d bytes", sizeof(GNSSData));
}

void loop() {
  static uint32_t last_heartbeat = 0;
  if (millis() - last_heartbeat > 5000) {
    LOG_INFO("HEALTH", "ç³»çµ±é‹è¡Œä¸­ - Free heap: %d", ESP.getFreeHeap());
    last_heartbeat = millis();
  }
  
  // è™•ç†é™¤éŒ¯æŒ‡ä»¤
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    if (cmd == "mem") {
      LOG_INFO("DEBUG", "Free heap: %d, Max alloc: %d", 
               ESP.getFreeHeap(), ESP.getMaxAllocHeap());
    }
  }
}
```

### éšæ®µäºŒï¼šUART + HAL æŠ½è±¡
```cpp
#include "src/util/log.h"
#include "src/hal/board_support.h"
#include "src/comm/uart_interface.h"

ArduinoUARTInterface gnss{hal::SERIAL_GNSS};
ArduinoUARTInterface imu{hal::SERIAL_IMU};

void setup() {
  hal::initPins();
  hal::initUarts();
  
  bool gnss_ok = gnss.initialize(38400);
  bool imu_ok = imu.initialize(115200);
  
  LOG_INFO("SYSTEM", "UART åˆå§‹åŒ– - GNSS: %s, IMU: %s", 
           gnss_ok ? "OK" : "FAIL", imu_ok ? "OK" : "FAIL");
}

void loop() {
  uint32_t loop_start = micros();
  uint32_t budget_us = 2000;  // 2ms é ç®—
  
  // éé˜»å¡è®€å– UART
  char buffer[256];
  size_t gnss_bytes = gnss.readLine(buffer, sizeof(buffer));
  if (gnss_bytes > 0) {
    LOG_INFO("GNSS", "æ¥æ”¶: %s", buffer);
  }
  
  size_t imu_bytes = imu.available();
  if (imu_bytes > 0) {
    LOG_INFO("IMU", "å¯ç”¨è³‡æ–™: %d bytes", imu_bytes);
  }
  
  uint32_t elapsed = micros() - loop_start;
  if (elapsed > budget_us) {
    LOG_WARN("TIMING", "è¶…æ™‚: %lu/%lu us", elapsed, budget_us);
  }
}
```

### éšæ®µä¸‰ï¼šé€šè¨Šç®¡ç†å™¨ + äº‹ä»¶é©…å‹•
```cpp
#include "src/util/log.h"
#include "src/comm/communication_manager.h"
#include "src/util/task_scheduler.h"

CommunicationManager comm_manager;
TaskScheduler scheduler;

void onGNSSData(const GNSSData& data) {
  LOG_INFO("GNSS", "ä½ç½®: %.6f, %.6f, è¡›æ˜Ÿ: %d, HDOP: %.2f", 
           data.latitude, data.longitude, data.num_satellites, data.hdop);
}

void onIMUData(const IMUData& data) {
  LOG_INFO("IMU", "åŠ é€Ÿåº¦: (%.2f, %.2f, %.2f), æº«åº¦: %.1fÂ°C", 
           data.accel_x, data.accel_y, data.accel_z, data.temperature);
}

void setup() {
  hal::initPins();
  hal::initUarts();
  
  CommunicationConfig config{};
  config.baud_rates[static_cast<int>(ChannelId::GNSS)] = 38400;
  config.baud_rates[static_cast<int>(ChannelId::IMU)] = 115200;
  config.channel_enabled[static_cast<int>(ChannelId::GNSS)] = true;
  config.channel_enabled[static_cast<int>(ChannelId::IMU)] = true;
  config.timeout_ms = 1000;
  
  bool ok = comm_manager.initialize(config);
  LOG_INFO("SYSTEM", "é€šè¨Šç®¡ç†å™¨åˆå§‹åŒ–: %s", ok ? "æˆåŠŸ" : "å¤±æ•—");
  
  comm_manager.registerGNSSCallback(onGNSSData);
  comm_manager.registerIMUCallback(onIMUData);
  
  // è¨­å®šä»»å‹™æ’ç¨‹
  scheduler.every(10, []{ 
    uint32_t budget = 2000;
    comm_manager.processIncomingData(); 
  });
  scheduler.every(1000, []{ 
    LOG_INFO("HEALTH", "é€šè¨Šçµ±è¨ˆ - GNSS: %lu packets, IMU: %lu packets",
             comm_manager.getChannelStats(ChannelId::GNSS).packets_processed,
             comm_manager.getChannelStats(ChannelId::IMU).packets_processed);
  });
}

void loop() {
  scheduler.tick();
  
  // è™•ç†é™¤éŒ¯æŒ‡ä»¤
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    if (cmd == "comm_stats") {
      for (int i = 0; i < static_cast<int>(ChannelId::MAX_CHANNELS); i++) {
        auto stats = comm_manager.getChannelStats(static_cast<ChannelId>(i));
        LOG_INFO("DEBUG", "Ch%d: RX=%lu, TX=%lu, Errors=%lu", 
                 i, stats.bytes_received, stats.bytes_sent, stats.error_count);
      }
    }
  }
}
```

### éšæ®µå››ï¼šShift æ ¡æ­£ç³»çµ±
```cpp
#include "src/util/log.h"
#include "src/comm/communication_manager.h"
#include "src/fusion/shift_calibrator.h"
#include "src/util/task_scheduler.h"

CommunicationManager comm_manager;
ShiftCalibrator shift_calibrator;
TaskScheduler scheduler;

// Shift æ ¡æ­£å›èª¿å‡½æ•¸
void onShiftCalibrationComplete(float shift_offset) {
  LOG_INFO("SHIFT", "æ ¡æ­£å®Œæˆ - åç§»é‡: %.4fÂ°", shift_offset);
}

void onShiftUpdate(float current_shift, float gnss_heading, float imu_yaw) {
  LOG_INFO("SHIFT", "å‹•æ…‹æ›´æ–° - GNSS: %.2fÂ°, IMU: %.2fÂ°, Shift: %.4fÂ°", 
           gnss_heading, imu_yaw, current_shift);
}

void setup() {
  hal::initPins();
  hal::initUarts();
  
  // åˆå§‹åŒ–é€šè¨Šç®¡ç†å™¨
  CommunicationConfig comm_config{};
  comm_config.baud_rates[static_cast<int>(ChannelId::GNSS)] = 38400;
  comm_config.baud_rates[static_cast<int>(ChannelId::IMU)] = 115200;
  comm_config.channel_enabled[static_cast<int>(ChannelId::GNSS)] = true;
  comm_config.channel_enabled[static_cast<int>(ChannelId::IMU)] = true;
  
  bool comm_ok = comm_manager.initialize(comm_config);
  LOG_INFO("SYSTEM", "é€šè¨Šç®¡ç†å™¨: %s", comm_ok ? "æˆåŠŸ" : "å¤±æ•—");
  
  // åˆå§‹åŒ– Shift æ ¡æ­£å™¨
  ShiftCalibrationConfig shift_config{};
  shift_config.plshd_samples_required = 20;
  shift_config.mti_samples_required = 50;
  shift_config.setup_timeout_ms = 120000; // 2åˆ†é˜è¶…æ™‚
  shift_config.fusion_mode_enabled = true; // é è¨­ä½¿ç”¨ Fusion æ¨¡å¼
  
  bool shift_ok = shift_calibrator.initialize(shift_config);
  LOG_INFO("SYSTEM", "Shiftæ ¡æ­£å™¨: %s", shift_ok ? "æˆåŠŸ" : "å¤±æ•—");
  
  // è¨»å†Šå›èª¿å‡½æ•¸
  shift_calibrator.setCalibrationCompleteCallback(onShiftCalibrationComplete);
  shift_calibrator.setShiftUpdateCallback(onShiftUpdate);
  
  // å•Ÿå‹•åˆå§‹åŒ–æ ¡æ­£æµç¨‹
  LOG_INFO("SHIFT", "é–‹å§‹åˆå§‹åŒ–æ ¡æ­£æµç¨‹...");
  shift_calibrator.startSetupCalibration();
  
  // è¨­å®šä»»å‹™æ’ç¨‹
  scheduler.every(10, []{ 
    comm_manager.processIncomingData(); 
    shift_calibrator.update();
  });
  scheduler.every(5000, []{ 
    auto shift_status = shift_calibrator.getStatus();
    LOG_INFO("HEALTH", "Shiftç‹€æ…‹: %s, ç•¶å‰åç§»: %.4fÂ°", 
             shift_status.is_calibrated ? "å·²æ ¡æ­£" : "æ ¡æ­£ä¸­",
             shift_status.current_offset);
  });
}

void loop() {
  scheduler.tick();
  
  // è™•ç†é™¤éŒ¯æŒ‡ä»¤
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    if (cmd == "shift_info") {
      shift_calibrator.printDetailedStatus();
    } else if (cmd == "recalibrate") {
      LOG_INFO("DEBUG", "æ‰‹å‹•é‡æ–°æ ¡æ­£...");
      shift_calibrator.startSetupCalibration();
    } else if (cmd == "toggle_mode") {
      bool current_mode = shift_calibrator.isFusionModeEnabled();
      shift_calibrator.setFusionMode(!current_mode);
      LOG_INFO("DEBUG", "åˆ‡æ›åˆ° %s æ¨¡å¼", !current_mode ? "Fusion" : "æ¨™æº–");
    }
  }
}
```

### æœ€çµ‚ç‰ˆï¼šå®Œæ•´ç³»çµ±æ§åˆ¶å™¨
```cpp
#include "src/core/system_controller.h"
#include "src/util/task_scheduler.h"

SystemController system_controller;
TaskScheduler scheduler;

void setup() {
  hal::initPins();
  hal::initUarts();
  
  if (!system_controller.initialize()) {
    LOG_ERR("SYSTEM", "ç³»çµ±åˆå§‹åŒ–å¤±æ•— - é€²å…¥å®‰å…¨æ¨¡å¼");
    // é€²å…¥æœ€å°åŠŸèƒ½æ¨¡å¼
    return;
  }
  
  LOG_INFO("SYSTEM", "GMINS ç³»çµ±å•Ÿå‹•å®Œæˆ");
  
  // ç³»çµ±ç´šä»»å‹™æ’ç¨‹
  scheduler.every(10, []{ system_controller.run(); });
  scheduler.every(5000, []{ 
    auto health = system_controller.getHealth();
    LOG_INFO("HEALTH", "é€šè¨Š: %s, èåˆ: %s, å®‰å…¨: %s, éŒ¯èª¤æ•¸: %lu",
             health.communication_ok ? "OK" : "FAIL",
             health.fusion_ok ? "OK" : "FAIL", 
             health.safety_ok ? "OK" : "FAIL",
             health.error_count);
  });
}

void loop() {
  scheduler.tick();
  
  // ç³»çµ±ç´šé™¤éŒ¯æŒ‡ä»¤
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    if (cmd == "state") {
      LOG_INFO("DEBUG", "ç³»çµ±ç‹€æ…‹: %d, æ¨¡å¼: %d", 
               static_cast<int>(system_controller.getState()),
               static_cast<int>(system_controller.getMode()));
    } else if (cmd == "safe_mode") {
      system_controller.handleError("æ‰‹å‹•è§¸ç™¼å®‰å…¨æ¨¡å¼");
    }
  }
}
```

## ç²¾ç¢ºé©—æ”¶æ¨™æº–ï¼ˆå¯é‡æ¸¬æ¢ä»¶ï¼‰

### éšæ®µ 0.5 é©—æ”¶ï¼ˆé…ç½®ç®¡ç†åŸºç¤è¨­æ–½ï¼‰ğŸ†•
**é…ç½®è§£æèƒ½åŠ›ï¼š**
- [ ] TOML é…ç½®æ–‡ä»¶è§£ææˆåŠŸç‡ = 100%
- [ ] é…ç½®åƒæ•¸é©—è­‰å™¨æ””æˆªç„¡æ•ˆé…ç½® 100%
- [ ] ç†±æ›´æ–°é…ç½®ç”Ÿæ•ˆæ™‚é–“ < 1 ç§’
- [ ] åƒæ•¸æœå‹™å™¨éŸ¿æ‡‰æ™‚é–“ < 10ms
- [ ] é è¨­é…ç½®æ¨¡æ¿å®Œæ•´æ€§æª¢æŸ¥é€šé

**é…ç½®ç©©å®šæ€§ï¼š**
- [ ] ç„¡æ•ˆé…ç½®æª”æ¡ˆè™•ç†ä¸å´©æ½°
- [ ] é…ç½®ç‰ˆæœ¬å‡ç´šé·ç§»æˆåŠŸç‡ = 100%
- [ ] é…ç½®éŒ¯èª¤è‡ªå‹•å›æ»¾æ©Ÿåˆ¶æ­£å¸¸

### éšæ®µä¸€é©—æ”¶ï¼ˆåŸºç¤è³‡æ–™çµæ§‹ï¼‰
**ç·¨è­¯æ™‚æª¢æŸ¥ï¼š**
- [ ] `static_assert(sizeof(IMUData) <= 128, "IMUDataéå¤§")` é€šé
- [ ] `static_assert(sizeof(GNSSData) <= 256, "GNSSDataéå¤§")` é€šé
- [ ] `static_assert(sizeof(NavigationState) <= 512, "NavigationStateéå¤§")` é€šé

**å–®ä½ä¸€è‡´æ€§æª¢æŸ¥ï¼š**
- [ ] æ‰€æœ‰è§’åº¦å…§éƒ¨ä½¿ç”¨å¼§åº¦ï¼Œé¡¯ç¤ºä½¿ç”¨åº¦æ•¸
- [ ] æ‰€æœ‰æ™‚é–“æˆ³ä½¿ç”¨ `timestamp_us_t`ï¼ˆmicrosecondsï¼‰
- [ ] æ‰€æœ‰é€Ÿåº¦ä½¿ç”¨ SI å–®ä½ï¼ˆm/s, rad/sï¼‰

**é‹è¡Œæ™‚é©—è­‰ï¼š**
- [ ] æ—¥èªŒç³»çµ± 10 ç¨®æ¨¡çµ„æ¨™ç±¤æ­£å¸¸é‹ä½œ
- [ ] è¨˜æ†¶é«”ä½¿ç”¨é€£çºŒæ¸¬è©¦ 5 åˆ†é˜ç„¡å¢é•·
- [ ] å–®å…ƒæ¸¬è©¦è¦†è“‹ç‡ > 90%ï¼ˆè³‡æ–™çµæ§‹è½‰æ›å‡½æ•¸ï¼‰

### éšæ®µ 1.5 é©—æ”¶ï¼ˆæŒä¹…åŒ–å­˜å„²ç³»çµ±ï¼‰ğŸ†•
**NVS å­˜å„²æ€§èƒ½ï¼š**
- [ ] NVS è®€å–æ“ä½œéŸ¿æ‡‰æ™‚é–“ < 5ms
- [ ] NVS å¯«å…¥æ“ä½œéŸ¿æ‡‰æ™‚é–“ < 20ms
- [ ] å­˜å„²ç©ºé–“åˆ©ç”¨ç‡ç›£æ§æ­£å¸¸
- [ ] æ ¡æ­£æ•¸æ“šå­˜å„²/è®€å–ä¸€è‡´æ€§ = 100%

**æ•¸æ“šå®Œæ•´æ€§ï¼š**
- [ ] å­˜å„²æ•¸æ“š CRC æ ¡é©—é€šéç‡ = 100%
- [ ] å‚™ä»½æ¢å¾©æ©Ÿåˆ¶é©—è­‰æˆåŠŸ
- [ ] å·¥å» é‡ç½®å¾Œç³»çµ±æ­£å¸¸å•Ÿå‹•
- [ ] æ•¸æ“šç‰ˆæœ¬é·ç§»æˆåŠŸç‡ = 100%

### éšæ®µäºŒé©—æ”¶ï¼ˆHAL + UARTï¼‰
**å•Ÿå‹•æª¢æŸ¥ï¼ˆ10ç§’å…§ï¼‰ï¼š**
- [ ] GNSS é€šé“æ¥æ”¶ä½å…ƒçµ„æ•¸ > 100 bytes
- [ ] IMU é€šé“æ¥æ”¶ä½å…ƒçµ„æ•¸ > 500 bytes  
- [ ] UART éŒ¯èª¤è¨ˆæ•¸å™¨ = 0ï¼ˆæ‰€æœ‰é€šé“ï¼‰
- [ ] HAL åˆå§‹åŒ–æˆåŠŸç‡ = 100%

**æ™‚é–“é ç®—æª¢æŸ¥ï¼š**
- [ ] Loop åŸ·è¡Œæ™‚é–“ < 2000usï¼ˆé ç®— 2msï¼‰
- [ ] UART è®€å–æ“ä½œ < 500us 
- [ ] æ™‚é–“é ç®—è¶…æ™‚å‘Šè­¦ = 0 æ¬¡

**ç¡¬é«”æŠ½è±¡é©—è­‰ï¼š**
- [ ] æ›´æ›ç¡¬é«”å®šç¾©å¾Œé‡æ–°ç·¨è­¯æˆåŠŸ
- [ ] ä¸Šå±¤ä»£ç¢¼é›¶ä¿®æ”¹å³å¯åˆ‡æ›æ¿å­

### éšæ®µ 2.5 é©—æ”¶ï¼ˆæ•¸æ“šå“è³ªè©•ä¼°ç³»çµ±ï¼‰ğŸ†•
**æ•¸æ“šå“è³ªæŒ‡æ¨™ï¼š**
- [ ] GNSS æ•¸æ“šå“è³ªè©•åˆ†ç®—æ³•æº–ç¢ºç‡ > 95%
- [ ] IMU æ•¸æ“šç•°å¸¸æª¢æ¸¬æˆåŠŸç‡ > 99%
- [ ] ä¿¡è™Ÿå®Œæ•´æ€§ç›£æ§éŸ¿æ‡‰æ™‚é–“ < 100ms
- [ ] å“è³ªæŒ‡æ¨™è¨ˆç®—æ™‚é–“ < 50us

**ç•°å¸¸è™•ç†èƒ½åŠ›ï¼š**
- [ ] ç•°å¸¸å€¼æª¢æ¸¬ç²¾ç¢ºåº¦ > 98%
- [ ] æ•¸æ“šå“è³ªé™ç´šå‘Šè­¦åŠæ™‚æ€§ < 1 ç§’
- [ ] å“è³ªè©•ä¼°æ¼”ç®—æ³•è³‡æºæ¶ˆè€— < 5% CPU

### éšæ®µä¸‰é©—æ”¶ï¼ˆé€šè¨Šç®¡ç†ï¼‰
**è§£ææ€§èƒ½æŒ‡æ¨™ï¼š**
- [ ] NMEA å¥å­è§£ææˆåŠŸç‡ > 98%
- [ ] XBUS å°åŒ…è§£ææˆåŠŸç‡ > 99%
- [ ] ç¸½é«”ä¸ŸåŒ…ç‡ < 1%
- [ ] è§£ææ™‚é–“ < 1500usï¼ˆé ç®—å…§å®Œæˆï¼‰

**éŒ¯èª¤æ¢å¾©æª¢é©—ï¼š**
- [ ] é€šè¨Šä¸­æ–·è‡ªå‹•æ¢å¾©æˆåŠŸç‡ = 100%ï¼ˆæ¸¬è©¦10æ¬¡ï¼‰
- [ ] éŒ¯èª¤å¾Œ 5 ç§’å…§æ¢å¾©æ­£å¸¸è³‡æ–™æµ
- [ ] çµ±è¨ˆè¨ˆæ•¸å™¨ç²¾ç¢ºç´¯ç©ï¼ˆäººå·¥é©—è­‰ï¼‰

**ç©©å®šæ€§æ¸¬è©¦ï¼š**
- [ ] é€£çºŒé‹è¡Œ 30 åˆ†é˜ç„¡ç•°å¸¸
- [ ] äº‹ä»¶å›èª¿éŸ¿æ‡‰æ™‚é–“ < 100us

### éšæ®µ 3.5 é©—æ”¶ï¼ˆå¤šå”è­°æ¸¬è©¦é©—è­‰æ¡†æ¶ï¼‰ğŸ†•
**æ¸¬è©¦æ¡†æ¶å®Œæ•´æ€§ï¼š**
- [ ] ä¸‰ç¨®å”è­°æ¨¡æ“¬æ¥æ”¶å™¨æ­£å¸¸é‹ä½œ
- [ ] è‡ªå‹•åŒ–æ¸¬è©¦è¦†è“‹ç‡ > 95%
- [ ] åˆ‡æ›å®‰å…¨æ€§æ¸¬è©¦é€šéç‡ = 100%
- [ ] æ€§èƒ½åŸºæº–æ¸¬è©¦çµæœç¬¦åˆé æœŸ

**æ¸¬è©¦åŸ·è¡Œæ•ˆç‡ï¼š**
- [ ] å®Œæ•´æ¸¬è©¦å¥—ä»¶åŸ·è¡Œæ™‚é–“ < 10 åˆ†é˜
- [ ] å£“åŠ›æ¸¬è©¦é‹è¡Œ 1 å°æ™‚ç©©å®š
- [ ] å›æ­¸æ¸¬è©¦è‡ªå‹•è§¸ç™¼æ­£å¸¸

### éšæ®µå››é©—æ”¶ï¼ˆShift æ ¡æ­£ç³»çµ±ï¼‰
**æ•¸æ“šæ”¶é›†æŒ‡æ¨™ï¼š**
- [ ] åœ¨ 120 ç§’å…§æ”¶é›† 20 å€‹æœ‰æ•ˆ PLSHD æ¨£æœ¬
- [ ] æ”¶é›† 50 å€‹ MTI åèˆªè§’æ¨£æœ¬ï¼ˆç©©å®šæ€§æª¢æŸ¥ï¼‰
- [ ] æ¨£æœ¬æœ‰æ•ˆæ€§æª¢æŸ¥é€šéç‡ > 95%

**æ ¡æ­£ç²¾åº¦è¦æ±‚ï¼š**
- [ ] åˆå§‹åŒ–æ ¡æ­£è¨ˆç®—èª¤å·® < 0.5Â°
- [ ] å‹•æ…‹æ ¡æ­£éŸ¿æ‡‰æ™‚é–“ < 1 ç§’
- [ ] é€£çºŒæ ¡æ­£ç©©å®šåº¦ < 0.1Â°/å°æ™‚

**æ¨¡å¼åˆ‡æ›æ¸¬è©¦ï¼š**
- [ ] Fusion/æ¨™æº–æ¨¡å¼åˆ‡æ›æ™‚é–“ < 100ms
- [ ] æ¨¡å¼åˆ‡æ›å¾Œæ ¡æ­£å€¼é€£çºŒæ€§ä¿æŒ
- [ ] NaN å€¼æª¢æ¸¬å’Œæ¢å¾© 100% æˆåŠŸ

**è¨ºæ–·åŠŸèƒ½é©—è­‰ï¼š**
- [ ] Debug æŒ‡ä»¤å›æ‡‰æ™‚é–“ < 50ms
- [ ] ç‹€æ…‹è¼¸å‡ºæ ¼å¼å®Œæ•´æ€§ 100%

### éšæ®µ 4.5 é©—æ”¶ï¼ˆèåˆæ¼”ç®—æ³•æ•¸å­¸åº«ï¼‰ğŸ†•
**æ•¸å­¸é‹ç®—æ€§èƒ½ï¼š**
- [ ] çŸ©é™£é‹ç®—ç²¾åº¦èª¤å·® < 1e-6
- [ ] å››å…ƒæ•¸æ­£è¦åŒ–ä¿æŒç²¾åº¦ > 1e-8
- [ ] çµ±è¨ˆå‡½æ•¸è¨ˆç®—æ™‚é–“ < 10us
- [ ] åæ¨™è½‰æ›é‹ç®—ç²¾åº¦ > 1e-5

**æ•¸å€¼ç©©å®šæ€§ï¼š**
- [ ] çŸ©é™£é‹ç®—ç„¡ NaN/Inf ç”¢ç”Ÿ
- [ ] é•·æœŸé‹ç®—ç´¯ç©èª¤å·® < 1e-4
- [ ] EKF å”æ–¹å·®çŸ©é™£æ­£å®šæ€§ä¿æŒ 100%

### éšæ®µäº”é©—æ”¶ï¼ˆèåˆæ¼”ç®—æ³•ï¼‰
**èåˆæ€§èƒ½æŒ‡æ¨™ï¼š**
- [ ] EKF æ”¶æ–‚æ™‚é–“ < 30 ç§’
- [ ] ä½ç½®ä¼°è¨ˆèª¤å·® < 2 ç±³ï¼ˆCEP 95%ï¼‰
- [ ] å§¿æ…‹ä¼°è¨ˆèª¤å·® < 2Â°ï¼ˆRMSï¼‰
- [ ] èåˆé »ç‡ç¶­æŒ > 50Hz

**ç®—æ³•ç©©å®šæ€§ï¼š**
- [ ] å”æ–¹å·®çŸ©é™£æ­£å®šæ€§ä¿æŒ 100%
- [ ] æ•¸å€¼ç©©å®šæ€§æ¸¬è©¦é€šéï¼ˆç„¡ NaN/Infï¼‰
- [ ] é•·æœŸæ¼‚ç§» < 5 ç±³/å°æ™‚

### éšæ®µ 5.5 é©—æ”¶ï¼ˆé«˜ç´šè¨ºæ–·èˆ‡ç›£æ§ç³»çµ±ï¼‰ğŸ†•
**ç›£æ§ç³»çµ±æ€§èƒ½ï¼š**
- [ ] å¥åº·ç›£æ§å™¨è³‡æºæ¶ˆè€— < 2% CPU
- [ ] æ€§èƒ½ç›£æ§æ•¸æ“šæ”¶é›†æº–ç¢ºç‡ = 100%
- [ ] é ç¨‹è¨ºæ–·ä»‹é¢éŸ¿æ‡‰æ™‚é–“ < 100ms
- [ ] å‘Šè­¦ç³»çµ±è§¸ç™¼å»¶é² < 500ms

**è¨ºæ–·åŠŸèƒ½å®Œæ•´æ€§ï¼š**
- [ ] ç³»çµ±ç‹€æ…‹å ±å‘Šå®Œæ•´æ€§ = 100%
- [ ] é™æ¸¬æ•¸æ“šæ ¼å¼æ­£ç¢ºæ€§é©—è­‰é€šé
- [ ] Web è¨ºæ–·ä»‹é¢åŠŸèƒ½è¦†è“‹ç‡ > 90%

### éšæ®µå…­é©—æ”¶ï¼ˆå®‰å…¨ç³»çµ±ï¼‰
**ç›£æ§æŒ‡æ¨™ï¼š**
- [ ] å®‰å…¨æª¢æŸ¥éŸ¿æ‡‰æ™‚é–“ < 10ms
- [ ] æ•…éšœæª¢æ¸¬æº–ç¢ºç‡ > 99%
- [ ] å®‰å…¨æ¨¡å¼åˆ‡æ›æ™‚é–“ < 200ms

**å®¹éŒ¯èƒ½åŠ›ï¼š**
- [ ] å–®ä¸€æ„Ÿæ¸¬å™¨æ•…éšœè™•ç†æˆåŠŸ
- [ ] é€šè¨Šä¸­æ–·å¾Œç³»çµ±ç©©å®šé‹è¡Œ
- [ ] ç•°å¸¸æ¢å¾©æ™‚é–“ < 5 ç§’

### éšæ®µ 6.5 é©—æ”¶ï¼ˆOTA æ›´æ–°ç³»çµ±ï¼‰ğŸ†•
**æ›´æ–°æ©Ÿåˆ¶å¯é æ€§ï¼š**
- [ ] å›ºä»¶ä¸‹è¼‰æˆåŠŸç‡ > 99%
- [ ] æ•¸ä½ç°½ç« é©—è­‰é€šéç‡ = 100%
- [ ] å¢é‡æ›´æ–°ç¯€çœç©ºé–“ > 70%
- [ ] æ›´æ–°å¤±æ•—è‡ªå‹•å›æ»¾æˆåŠŸç‡ = 100%

**æ›´æ–°æ€§èƒ½æŒ‡æ¨™ï¼š**
- [ ] å®Œæ•´å›ºä»¶æ›´æ–°æ™‚é–“ < 10 åˆ†é˜
- [ ] æ›´æ–°éç¨‹ä¸­ç³»çµ±ç©©å®šæ€§ä¿æŒ
- [ ] ç‰ˆæœ¬ç®¡ç†è¨˜éŒ„å®Œæ•´æ€§ = 100%

### æœ€çµ‚ç‰ˆé©—æ”¶ï¼ˆç³»çµ±æ•´åˆï¼‰
**é•·æœŸç©©å®šæ€§ï¼ˆ24å°æ™‚æ¸¬è©¦ï¼‰ï¼š** ğŸ†•
- [ ] é€£çºŒé‹è¡Œ 24 å°æ™‚é›¶å´©æ½°
- [ ] CPU ä½¿ç”¨ç‡å¹³å‡ < 70%ï¼Œå³°å€¼ < 85%
- [ ] è¨˜æ†¶é«”ä½¿ç”¨é‡ç©©å®šï¼ˆÂ±3% ä»¥å…§ï¼‰
- [ ] çœ‹é–€ç‹—è§¸ç™¼æ¬¡æ•¸ = 0

**æ€§èƒ½åŸºæº–ï¼š**
- [ ] ä¸»å¾ªç’°é »ç‡ç¶­æŒ > 100Hz
- [ ] è³‡æ–™è™•ç†å»¶é² < 50ms
- [ ] ç³»çµ±éŸ¿æ‡‰æ™‚é–“ < 100ms
- [ ] æ‰€æœ‰æ¨¡çµ„æ™‚é–“é ç®—é”æ¨™ç‡ > 98%

**å¯é æ€§æŒ‡æ¨™ï¼š**
- [ ] MTBFï¼ˆå¹³å‡æ•…éšœé–“éš”æ™‚é–“ï¼‰> 48 å°æ™‚ ğŸ†•
- [ ] è‡ªå‹•éŒ¯èª¤æ¢å¾©æˆåŠŸç‡ > 98%
- [ ] ç³»çµ±å¥åº·åº¦å§‹çµ‚ > 95%

**å·¥æ¥­ç´šé©—è­‰ï¼š** ğŸ†•
- [ ] æ¨¡æ“¬ 15 ç¨®æ•…éšœå ´æ™¯å…¨éƒ¨é€šé
- [ ] ç¾å ´ç’°å¢ƒæ¸¬è©¦ç©©å®šé‹è¡Œ > 72 å°æ™‚
- [ ] ç”¨æˆ¶æ“ä½œå›æ‡‰æº–ç¢ºç‡ 100%
- [ ] ç’°å¢ƒé©æ‡‰æ€§æ¸¬è©¦é€šéï¼ˆæº«åº¦ã€æ¿•åº¦ã€éœ‡å‹•ï¼‰

## å®Œæ•´ç³»çµ±æ¶æ§‹ç¸½è¦½åœ–

### ğŸ—ï¸ ç³»çµ±åˆ†å±¤çµæ§‹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        GMINS.ino                           â”‚
â”‚                     (ç³»çµ±æ•´åˆå±¤)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SystemController  â”‚  TaskScheduler  â”‚  DiagnosticCLI    â”‚
â”‚     (æ ¸å¿ƒæ§åˆ¶)      â”‚   (ä»»å‹™æ’ç¨‹)    â”‚   (è¨ºæ–·ä»‹é¢)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SafetyGuardian â”‚ HealthMonitor â”‚ ConfigManager â”‚ OTAUpdater â”‚
â”‚   (å®‰å…¨ç›£æ§)    â”‚   (å¥åº·ç›£æ§)   â”‚  (é…ç½®ç®¡ç†)    â”‚ (OTAæ›´æ–°)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FusionEngine  â”‚ ShiftCalibrator â”‚ DataValidator â”‚ TestFramework â”‚
â”‚   (èåˆå¼•æ“)    â”‚   (Shiftæ ¡æ­£)   â”‚  (æ•¸æ“šå“è³ª)    â”‚  (æ¸¬è©¦æ¡†æ¶)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    CommunicationManager    â”‚      ProtocolManager         â”‚
â”‚       (é€šè¨Šç®¡ç†å™¨)          â”‚      (å”è­°ç®¡ç†å™¨)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MAVLinkProtocol â”‚ AR1AFCProtocol â”‚ MTINativeProtocol      â”‚
â”‚   (MAVLink)     â”‚   (AR1A-FC)    â”‚   (MTIé€å‚³)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UARTTransport  â”‚  UDPTransport  â”‚  USBTransport          â”‚
â”‚   (UARTå‚³è¼¸)    â”‚   (UDPå‚³è¼¸)    â”‚   (USBå‚³è¼¸)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           HAL (Hardware Abstraction Layer)                 â”‚
â”‚              (ç¡¬é«”æŠ½è±¡å±¤)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  NVSStorage  â”‚  MathLibrary  â”‚  TimingBudget  â”‚  LogSystem â”‚
â”‚  (å­˜å„²ç®¡ç†)   â”‚  (æ•¸å­¸å‡½æ•¸)    â”‚  (æ™‚é–“é ç®—)     â”‚ (æ—¥èªŒç³»çµ±)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Hardware Layer                          â”‚
â”‚      (ESP32/Arduino + GNSS + IMU + ä¸²å£)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”„ æ•¸æ“šæµå‘åœ–
```
ç¡¬é«”æ„Ÿæ¸¬å™¨ â†’ HAL â†’ å‚³è¼¸å±¤ â†’ å”è­°è§£æ â†’ æ•¸æ“šé©—è­‰ â†’ Shiftæ ¡æ­£ â†’ èåˆæ¼”ç®—æ³• â†’ å¤šå”è­°è¼¸å‡º
     â†‘                                                              â†“
é…ç½®ç®¡ç† â† å­˜å„²ç³»çµ± â† è¨ºæ–·ç³»çµ± â† å®‰å…¨ç›£æ§ â† å¥åº·ç›£æ§ â† ç³»çµ±æ§åˆ¶å™¨
```

## ä¸‹ä¸€æ­¥è¡Œå‹•ï¼ˆå®Œæ•´é–‹ç™¼è·¯ç·šåœ–ï¼‰

### ğŸ¯ Phase 1: åŸºç¤è¨­æ–½å»ºè¨­ (1-2é€±)
**å¾ `data_types.h` + çµ±ä¸€æ—¥èªŒé–‹å§‹ï¼Œæ¡ç”¨å¯¦æˆ°ç´šæ¶æ§‹ï¼š**
1. **éšæ®µ 0.5**: å»ºç«‹é…ç½®ç®¡ç†ç³»çµ±åŸºç¤è¨­æ–½
2. **éšæ®µ 1**: å»ºç«‹å®Œæ•´çš„è³‡æ–™å‹åˆ¥å®šç¾©ï¼ˆå«æ¨™æº–åŒ–æ™‚é–“æˆ³ï¼‰
3. **éšæ®µ 1.5**: å¯¦ç¾æŒä¹…åŒ–å­˜å„²ç³»çµ±
4. **éšæ®µ 2**: å»ºç«‹ HAL æŠ½è±¡å±¤

### ğŸ¯ Phase 2: æ ¸å¿ƒåŠŸèƒ½é–‹ç™¼ (2-3é€±)
5. **éšæ®µ 2.5**: å¯¦ç¾æ•¸æ“šå“è³ªè©•ä¼°ç³»çµ±
6. **éšæ®µ 3**: é–‹ç™¼å¤šå”è­°è¼¸å‡ºç³»çµ± (æ ¸å¿ƒç‰¹è‰²)
7. **éšæ®µ 3.5**: å»ºç«‹å¤šå”è­°æ¸¬è©¦é©—è­‰æ¡†æ¶
8. **éšæ®µ 4**: æ•´åˆé…ç½®èˆ‡æ¨¡å¼ç®¡ç†

### ğŸ¯ Phase 3: é€²éšåŠŸèƒ½å¯¦ç¾ (2-3é€±)
9. **éšæ®µ 4.5**: å¯¦ç¾èåˆæ¼”ç®—æ³•æ•¸å­¸åº«
10. **éšæ®µ 5**: é–‹ç™¼ Shift æ ¡æ­£ç³»çµ±
11. **éšæ®µ 5.5**: å»ºç«‹é«˜ç´šè¨ºæ–·èˆ‡ç›£æ§ç³»çµ±
12. **éšæ®µ 6**: å¯¦ç¾å®Œæ•´è³‡æ–™èåˆæ¼”ç®—æ³•

### ğŸ¯ Phase 4: ç³»çµ±æ•´åˆèˆ‡å„ªåŒ– (1-2é€±)
13. **éšæ®µ 6.5**: å¯¦ç¾ OTA æ›´æ–°ç³»çµ±
14. **éšæ®µ 7**: å®Œå–„å®‰å…¨ç³»çµ±èˆ‡é‹è¡Œæ™‚æ§åˆ¶
15. **éšæ®µ 8**: ç³»çµ±æ•´åˆèˆ‡æœ€çµ‚å„ªåŒ–

### ğŸ“Š é—œéµæˆåŠŸæŒ‡æ¨™
- **é–‹ç™¼é€²åº¦**: æ¯éšæ®µéƒ½æœ‰æ˜ç¢ºçš„é‡Œç¨‹ç¢‘å’Œé©—æ”¶æ¨™æº–
- **ä»£ç¢¼å“è³ª**: å–®å…ƒæ¸¬è©¦è¦†è“‹ç‡ > 90%ï¼Œé›†æˆæ¸¬è©¦é€šéç‡ = 100%
- **ç³»çµ±ç©©å®šæ€§**: 24å°æ™‚é€£çºŒé‹è¡Œé›¶å´©æ½°ï¼ŒMTBF > 48å°æ™‚
- **æ€§èƒ½æŒ‡æ¨™**: ä¸»å¾ªç’° > 100Hzï¼Œç³»çµ±éŸ¿æ‡‰ < 100ms
- **å·¥æ¥­ç´šæ¨™æº–**: é€šé15ç¨®æ•…éšœå ´æ™¯ï¼Œç’°å¢ƒé©æ‡‰æ€§æ¸¬è©¦é€šé

## ğŸ¯ Shift æ ¡æ­£ç³»çµ±è©³ç´°èªªæ˜

### ç³»çµ±åŠŸèƒ½æ¦‚è¿°
**Shift æ ¡æ­£ç³»çµ±æ˜¯ GMINS çš„æ ¸å¿ƒæ ¡æ­£æ¨¡çµ„**ï¼Œè§£æ±º GNSS èˆªå‘æ•¸æ“šå’Œ IMU åèˆªè§’æ•¸æ“šä¹‹é–“çš„ç³»çµ±æ€§åå·®å•é¡Œã€‚

### å·¥ä½œåŸç†
1. **åˆå§‹åŒ–æ ¡æ­£ï¼ˆSetupéšæ®µï¼‰**
   - æ”¶é›† 20 å€‹ PLSHDï¼ˆGNSSèˆªå‘ï¼‰æ¨£æœ¬
   - æ”¶é›† 50 å€‹ MTIï¼ˆIMUåèˆªè§’ï¼‰æ¨£æœ¬  
   - è¨ˆç®—å¹³å‡å€¼å·®ç•°ä½œç‚ºåŸºç¤æ ¡æ­£åç§»é‡

2. **å‹•æ…‹æ ¡æ­£ï¼ˆé‹è¡Œæ™‚ï¼‰**
   - å¯¦æ™‚æ¯”è¼ƒ GNSS èˆªå‘å’Œ IMU åèˆªè§’
   - å‹•æ…‹æ›´æ–°æ ¡æ­£åç§»é‡
   - è™•ç†ç•°å¸¸å€¼å’Œ NaN æ•¸æ“š

3. **å…©ç¨®å·¥ä½œæ¨¡å¼**
   - **Fusion æ¨¡å¼**ï¼šè™•ç†æ­æ‹‰è§’çš„ shift æ ¡æ­£
   - **æ¨™æº–æ¨¡å¼**ï¼šè™•ç†å››å…ƒæ•¸çš„ shift æ ¡æ­£

### é—œéµåƒæ•¸é…ç½®
```cpp
struct ShiftCalibrationConfig {
    uint8_t plshd_samples_required = 20;      // PLSHD æ¨£æœ¬æ•¸
    uint8_t mti_samples_required = 50;        // MTI æ¨£æœ¬æ•¸  
    uint32_t setup_timeout_ms = 120000;       // åˆå§‹åŒ–è¶…æ™‚
    bool fusion_mode_enabled = true;         // é è¨­ Fusion æ¨¡å¼
    float max_shift_change_rate = 1.0f;       // æœ€å¤§è®ŠåŒ–ç‡ Â°/s
    float outlier_threshold = 10.0f;          // ç•°å¸¸å€¼é–¾å€¼
};
```

### è¼¸å‡ºæ ¼å¼ç¯„ä¾‹
```
ğŸ“Š æ­æ‹‰è§’Shiftæ ¡æ­£çµæœ (Fusionæ¨¡å¼):
1. åŸå§‹æ­æ‹‰è§’: [Pitch=-2.34Â°, Roll=1.23Â°, Yaw=45.67Â°]
2. å¯¦éš›Shiftå€¼: 3.4567Â°
3. æ ¡æ­£å¾Œæ­æ‹‰è§’: [Pitch=-2.34Â°, Roll=1.23Â°, Yaw=49.12Â°]
4. Fusionå››å…ƒæ•¸: [w=0.9239, x=0.0107, y=-0.0204, z=0.3827]
GNSS Heading: 49.1234Â° âœ…
```

### æ•´åˆåˆ°ç³»çµ±æ¶æ§‹çš„é‡è¦æ€§
- **æä¾›é«˜ç²¾åº¦èˆªå‘æ ¡æ­£** - æ¶ˆé™¤æ„Ÿæ¸¬å™¨é–“çš„ç³»çµ±èª¤å·®
- **æ”¯æ´å¤šæ¨¡å¼æ“ä½œ** - é©æ‡‰ä¸åŒçš„èåˆæ¼”ç®—æ³•éœ€æ±‚
- **å¯¦æ™‚è‡ªé©æ‡‰æ ¡æ­£** - å‹•æ…‹èª¿æ•´ä¿æŒé•·æœŸç©©å®šæ€§
- **ç•°å¸¸è™•ç†æ©Ÿåˆ¶** - ç¢ºä¿ç³»çµ±åœ¨å„ç¨®æ¢ä»¶ä¸‹çš„ç©©å¥æ€§

## ğŸ¯ ç©©å®šæ€§æ”¹é€²ç¸½çµ

### ç‚ºä»€éº¼é€™äº›æ”¹é€²è‡³é—œé‡è¦ï¼Ÿ

**1. å¯é‡æ¸¬é©—æ”¶æ¨™æº–**
- é¿å…ã€Œèƒ½è·‘å°±å¥½ã€çš„å¿ƒæ…‹ï¼Œæ¯å€‹åŠŸèƒ½éƒ½æœ‰æ˜ç¢ºçš„æ€§èƒ½æŒ‡æ¨™
- é€€åŒ–å•é¡Œèƒ½ç¬¬ä¸€æ™‚é–“è¢«ç™¼ç¾ï¼Œä¸æœƒç©ç´¯åˆ°å¾ŒæœŸ
- åœ˜éšŠæˆå“¡å°å“è³ªæ¨™æº–æœ‰çµ±ä¸€èªçŸ¥

**2. æ™‚é–“é ç®—æ§åˆ¶**
- é˜²æ­¢ç³»çµ±åœ¨é«˜è² è¼‰æ™‚å‡ºç¾å¡é “
- æ¯å€‹æ¨¡çµ„éƒ½æœ‰æ˜ç¢ºçš„åŸ·è¡Œæ™‚é–“é™åˆ¶
- æ–¹ä¾¿æ€§èƒ½åˆ†æå’Œå„ªåŒ–

**3. çµ±ä¸€æ™‚é–“åŸºæº–**  
- æ¶ˆé™¤ ms/usã€åº¦/å¼§åº¦è½‰æ›éŒ¯èª¤
- æ‰€æœ‰æ¨¡çµ„ä½¿ç”¨ç›¸åŒçš„æ™‚é–“åƒè€ƒé»
- ç°¡åŒ–æ™‚é–“åŒæ­¥å’Œè³‡æ–™èåˆ

**4. éŒ¯èª¤åˆ†é¡èˆ‡æ¢å¾©**
- ç³»çµ±åŒ–çš„éŒ¯èª¤è™•ç†ï¼Œä¸å†éºæ¼é‚Šç•Œæƒ…æ³
- è‡ªå‹•æ¢å¾©æ©Ÿåˆ¶æé«˜ç³»çµ±å¯é æ€§
- ä¾¿æ–¼éŒ¯èª¤çµ±è¨ˆå’Œè¶¨å‹¢åˆ†æ

**5. HAL é‚Šç•Œåš´æ ¼æ§åˆ¶**
- ç¡¬é«”å¹³å°é·ç§»æˆæœ¬å¤§å¹…é™ä½
- ä¸Šå±¤ä»£ç¢¼èˆ‡ç¡¬é«”å®Œå…¨è§£è€¦
- ä¾¿æ–¼å–®å…ƒæ¸¬è©¦å’Œæ¨¡æ“¬

**6. é›¶å‹•æ…‹é…ç½®**
- æ¶ˆé™¤è¨˜æ†¶é«”æ´©æ¼å’Œç¢ç‰‡å•é¡Œ
- ç³»çµ±é‹è¡Œæ™‚è¨˜æ†¶é«”ä½¿ç”¨å®Œå…¨å¯é æ¸¬
- æé«˜é•·æœŸç©©å®šæ€§

**7. ç·šä¸Šè¨ºæ–·èƒ½åŠ›**
- ç¾å ´å•é¡Œæ’é™¤æ•ˆç‡æé«˜ 10 å€
- å¯¦æ™‚ç›£æ§ç³»çµ±å¥åº·ç‹€æ³
- æ”¯æ´é ç¨‹ç¶­è­·å’Œå‡ç´š

### ğŸš€ å»ºè­°çš„å¯¦ä½œå„ªå…ˆé †åº

**éšæ®µ 0ï¼šåŸºç¤è¨­æ–½æº–å‚™ï¼ˆ1-2å¤©ï¼‰**
1. å»ºç«‹çµ±ä¸€æ™‚é–“åŸºæº–å’Œå–®ä½ç³»çµ±
2. å¯¦ç¾æ™‚é–“é ç®—æ§åˆ¶æ©Ÿåˆ¶  
3. å‰µå»ºéŒ¯èª¤åˆ†é¡å’Œæ¢å¾©æ¡†æ¶
4. æ­å»ºç·šä¸Šè¨ºæ–·ç³»çµ±éª¨æ¶

**éšæ®µ 1ï¼šè³‡æ–™çµæ§‹ï¼ˆåŠ å¼·ç‰ˆï¼‰**
- æ•´åˆæ¨™æº–åŒ–å–®ä½å’Œæ™‚é–“æˆ³
- æ·»åŠ ç·¨è­¯æ™‚å¤§å°æª¢æŸ¥
- å¯¦ç¾è¨˜æ†¶é«”ç®¡ç†ç­–ç•¥

**éšæ®µ 2-8ï¼šæŒ‰åŸè¨ˆåŠƒåŸ·è¡Œ**  
- æ¯å€‹éšæ®µéƒ½ä½¿ç”¨æ–°çš„ç©©å®šæ€§æ©Ÿåˆ¶
- åš´æ ¼æŒ‰ç…§å¯é‡æ¸¬é©—æ”¶æ¨™æº–é€²è¡Œ
- æŒçºŒç›£æ§ç³»çµ±å¥åº·æŒ‡æ¨™

### âš¡ ç«‹å³å¯ç”¨çš„è¨ºæ–·æŒ‡ä»¤

é–‹ç™¼éç¨‹ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨é€™äº›æŒ‡ä»¤ä¾†å³æ™‚è¨ºæ–·ï¼š

```
status          - é¡¯ç¤ºç³»çµ±æ•´é«”ç‹€æ…‹
comm_stats      - é€šè¨Šçµ±è¨ˆè³‡æ–™
mem_info        - è¨˜æ†¶é«”ä½¿ç”¨æƒ…æ³  
timing_report   - æ™‚é–“é ç®—ä½¿ç”¨å ±å‘Š
error_log       - éŒ¯èª¤æ—¥èªŒæŸ¥çœ‹
shift_info      - Shift æ ¡æ­£ç‹€æ…‹
fusion_status   - èåˆæ¼”ç®—æ³•ç‹€æ…‹
safe_mode       - æ‰‹å‹•é€²å…¥å®‰å…¨æ¨¡å¼
log_level 2     - è¨­å®šæ—¥èªŒç­‰ç´š
system_test     - åŸ·è¡Œç³»çµ±è‡ªæª¢
help            - é¡¯ç¤ºæ‰€æœ‰å¯ç”¨æŒ‡ä»¤
```

### ğŸ† é æœŸæˆæœ

å¯¦æ–½é€™äº›ç©©å®šæ€§æ”¹é€²å¾Œï¼Œä½ å°‡ç²å¾—ï¼š

- **é–‹ç™¼æ•ˆç‡æå‡ 50%** - å•é¡Œå¿«é€Ÿå®šä½å’Œè§£æ±º
- **ç³»çµ±ç©©å®šæ€§æå‡ 90%** - MTBF å¾å°æ™‚ç´šæå‡åˆ°å¤©ç´š
- **ç¶­è­·æˆæœ¬é™ä½ 70%** - è‡ªå‹•æ¢å¾©å’Œé ç¨‹è¨ºæ–·
- **ä»£ç¢¼å“è³ªæå‡** - çµ±ä¸€æ¨™æº–å’Œè‡ªå‹•æª¢æŸ¥
- **å¹³å°ç§»æ¤æˆæœ¬é™ä½ 80%** - HAL æŠ½è±¡åŒ–è¨­è¨ˆ

# 編碼規範

> **功能**: GMINS v2.0 專案編碼風格和開發標準  
> **版本**: v2.0  
> **最後更新**: 2025-08-08  
> **基於標準**: Google C++ Style Guide + 專案特定規則

## 🎯 編碼原則

### 核心原則
1. **可讀性優先**: 代碼應該易於閱讀和理解
2. **一致性**: 保持整個專案的風格一致
3. **簡潔性**: 避免不必要的複雜性
4. **可維護性**: 便於後續維護和擴展
5. **性能考量**: 在嵌入式環境中注重性能

## 📝 命名規範

### 1. 檔案命名
```cpp
// 標頭檔 - 小寫 + 底線
system_controller.h
communication_manager.h
fusion_engine.h

// 實作檔 - 與對應標頭檔同名
system_controller.cpp
communication_manager.cpp
fusion_engine.cpp

// 測試檔 - test_ 前綴
test_system_controller.cpp
test_communication_manager.cpp
```

### 2. 類別命名
```cpp
// 類別名稱 - PascalCase
class SystemController {
public:
    // 公開成員函數 - camelCase
    bool initialize();
    void processData();
    SystemState getCurrentState();
    
private:
    // 私有成員變數 - 底線後綴
    SystemState current_state_;
    bool is_initialized_;
    uint32_t error_count_;
};

// 結構體 - PascalCase
struct NavigationState {
    Vector3d position;
    Quaternion orientation;
    uint64_t timestamp_us;
};

// 列舉 - 大寫 + 底線
enum SystemState {
    STATE_UNINITIALIZED,
    STATE_INITIALIZING,
    STATE_RUNNING,
    STATE_ERROR
};
```

### 3. 函數和變數命名
```cpp
// 函數 - camelCase
bool initializeSystem();
void processIncomingData();
float calculateDistance(const Vector3d& p1, const Vector3d& p2);

// 區域變數 - camelCase
int sensorCount = 0;
float averageValue = 0.0f;
std::string errorMessage;

// 全域變數 - g_ 前綴 (盡量避免使用)
extern bool g_systemInitialized;
extern int g_debugLevel;

// 常數 - k 前綴 + PascalCase
static constexpr float kGravityAcceleration = 9.80665f;
static constexpr int kMaxSensorCount = 16;
static constexpr char kDefaultConfigFile[] = "gmins_config.txt";
```

### 4. 巨集定義
```cpp
// 巨集 - 全大寫 + 底線
#define GMINS_VERSION_MAJOR 2
#define GMINS_VERSION_MINOR 0
#define MAX_BUFFER_SIZE 1024

// 條件編譯 - 全大寫 + 底線
#ifdef DEBUG_MODE
    #define DEBUG_PRINT(msg) Serial.println(msg)
#else
    #define DEBUG_PRINT(msg)
#endif

// 函數式巨集 - 全大寫 + 底線
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

## 🏗️ 代碼格式

### 1. 縮排和空白
```cpp
// 使用 4 個空格縮排，不使用 Tab
class ExampleClass {
public:
    ExampleClass() : member_var_(0) {
        // 建構函數內容
    }
    
    void exampleFunction() {
        if (condition) {
            // if 區塊內容
            for (int i = 0; i < count; ++i) {
                // for 迴圈內容
                processItem(i);
            }
        } else {
            // else 區塊內容
            handleError();
        }
    }
    
private:
    int member_var_;
};
```

### 2. 大括號風格
```cpp
// ✅ 正確 - 開大括號在同一行
if (condition) {
    // 內容
}

while (isRunning) {
    // 內容
}

class ClassName {
public:
    // 內容
};

// ❌ 錯誤 - 開大括號在新行 (不使用)
if (condition)
{
    // 內容
}
```

### 3. 行長度限制
```cpp
// 每行最多 100 個字元
// ✅ 正確
bool result = processData(sensor_data, configuration_params, 
                         error_handler, logger);

// ❌ 錯誤 - 超過 100 字元
bool result = processData(sensor_data, configuration_params, error_handler, logger, additional_param);

// 長參數列表的處理
bool initializeSensors(
    const SensorConfig& imu_config,
    const SensorConfig& gps_config,
    const CommunicationConfig& comm_config,
    Logger* logger) {
    // 實作內容
}
```

### 4. 空行使用
```cpp
#include <Arduino.h>
#include <vector>

#include "system_controller.h"
#include "communication_manager.h"

namespace gmins {

class ExampleClass {
public:
    ExampleClass();
    ~ExampleClass();
    
    void initialize();
    void process();
    
private:
    void internalFunction();
    
    int member_variable_;
};

}  // namespace gmins
```

## 📚 代碼組織

### 1. 標頭檔結構
```cpp
// system_controller.h
#ifndef GMINS_CORE_SYSTEM_CONTROLLER_H_
#define GMINS_CORE_SYSTEM_CONTROLLER_H_

// 系統標頭檔
#include <memory>
#include <vector>

// 專案標頭檔
#include "communication/comm_manager.h"
#include "data/data_types.h"
#include "utils/logger.h"

namespace gmins {
namespace core {

// 前向宣告
class FusionEngine;
class SafetyGuardian;

/**
 * @brief 系統控制器類別
 * 
 * 負責整個 GMINS 系統的生命週期管理和模組協調。
 * 
 * @details
 * 此類別是 GMINS 系統的核心控制器，負責：
 * - 系統初始化和關閉
 * - 模組間協調
 * - 系統狀態管理
 * - 錯誤處理和恢復
 */
class SystemController {
public:
    /**
     * @brief 系統狀態列舉
     */
    enum SystemState {
        STATE_UNINITIALIZED = 0,  ///< 未初始化狀態
        STATE_INITIALIZING = 1,   ///< 正在初始化
        STATE_READY = 2,          ///< 準備就緒
        STATE_RUNNING = 3,        ///< 正常運行
        STATE_ERROR = 4,          ///< 錯誤狀態
        STATE_SHUTDOWN = 5        ///< 關閉狀態
    };
    
    /**
     * @brief 建構函數
     * @param logger 日誌記錄器指標
     */
    explicit SystemController(Logger* logger);
    
    /**
     * @brief 解構函數
     */
    ~SystemController();
    
    /**
     * @brief 初始化系統
     * @return true 初始化成功，false 初始化失敗
     */
    bool initialize();
    
    /**
     * @brief 主要運行迴圈
     */
    void run();
    
    /**
     * @brief 關閉系統
     */
    void shutdown();
    
    /**
     * @brief 獲取當前系統狀態
     * @return 當前系統狀態
     */
    SystemState getState() const { return current_state_; }
    
private:
    // 不允許複製和賦值
    SystemController(const SystemController&) = delete;
    SystemController& operator=(const SystemController&) = delete;
    
    /**
     * @brief 初始化子系統
     * @return true 成功，false 失敗
     */
    bool initializeSubsystems();
    
    /**
     * @brief 協調各模組運作
     */
    void coordinateModules();
    
    SystemState current_state_;
    Logger* logger_;
    std::unique_ptr<CommunicationManager> comm_manager_;
    std::unique_ptr<FusionEngine> fusion_engine_;
    std::unique_ptr<SafetyGuardian> safety_guardian_;
};

}  // namespace core
}  // namespace gmins

#endif  // GMINS_CORE_SYSTEM_CONTROLLER_H_
```

### 2. 實作檔結構
```cpp
// system_controller.cpp
#include "core/system_controller.h"

#include <Arduino.h>

#include "core/fusion_engine.h"
#include "core/safety_guardian.h"
#include "utils/logger.h"

namespace gmins {
namespace core {

namespace {
// 匿名命名空間中的內部常數和函數
constexpr uint32_t kInitializationTimeoutMs = 5000;
constexpr uint32_t kHeartbeatIntervalMs = 1000;

bool validateSystemConfiguration() {
    // 內部輔助函數
    return true;
}
}  // anonymous namespace

SystemController::SystemController(Logger* logger)
    : current_state_(STATE_UNINITIALIZED)
    , logger_(logger) {
    if (logger_ == nullptr) {
        // 使用預設日誌器
        logger_ = Logger::getInstance();
    }
}

SystemController::~SystemController() {
    if (current_state_ != STATE_SHUTDOWN) {
        shutdown();
    }
}

bool SystemController::initialize() {
    logger_->log(LogLevel::INFO, "Starting system initialization");
    
    current_state_ = STATE_INITIALIZING;
    
    if (!validateSystemConfiguration()) {
        logger_->log(LogLevel::ERROR, "System configuration validation failed");
        current_state_ = STATE_ERROR;
        return false;
    }
    
    if (!initializeSubsystems()) {
        logger_->log(LogLevel::ERROR, "Subsystem initialization failed");
        current_state_ = STATE_ERROR;
        return false;
    }
    
    current_state_ = STATE_READY;
    logger_->log(LogLevel::INFO, "System initialization completed successfully");
    return true;
}

void SystemController::run() {
    if (current_state_ != STATE_READY) {
        logger_->log(LogLevel::WARNING, "System not ready for operation");
        return;
    }
    
    current_state_ = STATE_RUNNING;
    logger_->log(LogLevel::INFO, "System started running");
    
    while (current_state_ == STATE_RUNNING) {
        coordinateModules();
        
        // 簡單的延遲控制
        delay(1);  // 1ms 延遲
    }
}

bool SystemController::initializeSubsystems() {
    // 創建通訊管理器
    comm_manager_ = std::make_unique<CommunicationManager>(logger_);
    if (!comm_manager_->initialize()) {
        return false;
    }
    
    // 創建融合引擎
    fusion_engine_ = std::make_unique<FusionEngine>(logger_);
    if (!fusion_engine_->initialize()) {
        return false;
    }
    
    // 創建安全守護
    safety_guardian_ = std::make_unique<SafetyGuardian>(logger_);
    if (!safety_guardian_->initialize()) {
        return false;
    }
    
    return true;
}

void SystemController::coordinateModules() {
    // 處理通訊
    comm_manager_->processIncomingData();
    
    // 處理感測器融合
    if (comm_manager_->hasNewSensorData()) {
        auto sensor_data = comm_manager_->getLatestSensorData();
        fusion_engine_->processSensorData(sensor_data);
    }
    
    // 安全檢查
    if (!safety_guardian_->checkSystemSafety()) {
        logger_->log(LogLevel::WARNING, "Safety check failed");
        current_state_ = STATE_ERROR;
    }
    
    // 發送導航狀態
    auto nav_state = fusion_engine_->getNavigationState();
    comm_manager_->sendNavigationState(nav_state);
}

void SystemController::shutdown() {
    logger_->log(LogLevel::INFO, "Starting system shutdown");
    
    current_state_ = STATE_SHUTDOWN;
    
    // 按相反順序關閉子系統
    safety_guardian_.reset();
    fusion_engine_.reset();
    comm_manager_.reset();
    
    logger_->log(LogLevel::INFO, "System shutdown completed");
}

}  // namespace core
}  // namespace gmins
```

## 💬 註釋規範

### 1. 文件註釋
```cpp
/**
 * @file system_controller.h
 * @brief GMINS 系統控制器定義
 * @author GMINS 開發團隊
 * @date 2025-08-08
 * @version 2.0
 * 
 * 此檔案包含 GMINS 系統的核心控制器類別定義，
 * 負責整個系統的生命週期管理和模組協調。
 */
```

### 2. 類別和函數註釋
```cpp
/**
 * @brief 計算兩點間的距離
 * 
 * 使用歐幾里得距離公式計算三維空間中兩點間的距離。
 * 
 * @param p1 第一個點的座標
 * @param p2 第二個點的座標
 * @return float 兩點間的距離（單位：米）
 * 
 * @note 此函數假設輸入座標使用相同的座標系統
 * @warning 當輸入向量包含 NaN 或無窮大時，結果未定義
 * 
 * @code
 * Vector3d point1{0.0, 0.0, 0.0};
 * Vector3d point2{1.0, 1.0, 1.0};
 * float distance = calculateDistance(point1, point2);
 * // distance = 1.732 (approximately)
 * @endcode
 */
float calculateDistance(const Vector3d& p1, const Vector3d& p2);
```

### 3. 行內註釋
```cpp
void processData() {
    // 檢查資料有效性
    if (!isDataValid()) {
        return;  // 早期返回，避免處理無效資料
    }
    
    float average = 0.0f;
    for (int i = 0; i < data_count; ++i) {
        average += data_array[i];  // 累加所有數值
    }
    average /= data_count;  // 計算平均值
    
    /* 
     * 複雜的處理邏輯說明：
     * 1. 首先進行低通濾波
     * 2. 然後應用卡爾曼濾波
     * 3. 最後進行數值穩定化
     */
    average = applyLowPassFilter(average);
    average = applyKalmanFilter(average);
    average = stabilizeValue(average);
}
```

## 🚨 錯誤處理

### 1. 異常安全
```cpp
// ✅ 良好的資源管理
class ResourceManager {
public:
    bool initialize() {
        // 使用 RAII 管理資源
        file_handle_ = std::make_unique<FileHandle>();
        if (!file_handle_->open("config.txt")) {
            return false;  // 自動清理
        }
        
        memory_buffer_ = std::make_unique<uint8_t[]>(1024);
        return true;
    }
    
private:
    std::unique_ptr<FileHandle> file_handle_;
    std::unique_ptr<uint8_t[]> memory_buffer_;
};

// ✅ 錯誤碼返回
enum class ErrorCode {
    SUCCESS = 0,
    INVALID_PARAMETER,
    INSUFFICIENT_MEMORY,
    HARDWARE_ERROR,
    TIMEOUT
};

ErrorCode processData(const SensorData& data, ProcessedData* result) {
    if (result == nullptr) {
        return ErrorCode::INVALID_PARAMETER;
    }
    
    if (!isValidData(data)) {
        return ErrorCode::INVALID_PARAMETER;
    }
    
    if (!allocateMemory()) {
        return ErrorCode::INSUFFICIENT_MEMORY;
    }
    
    // 處理邏輯
    *result = computeResult(data);
    return ErrorCode::SUCCESS;
}
```

### 2. 斷言使用
```cpp
#include <cassert>

// 開發時的斷言檢查
void processArray(const float* array, size_t size) {
    assert(array != nullptr);    // 參數驗證
    assert(size > 0);            // 大小驗證
    assert(size <= MAX_SIZE);    // 邊界檢查
    
    for (size_t i = 0; i < size; ++i) {
        assert(!std::isnan(array[i]));  // 數值有效性檢查
        // 處理邏輯
    }
}

// 自定義斷言巨集
#ifdef DEBUG_MODE
    #define GMINS_ASSERT(condition, message) \
        do { \
            if (!(condition)) { \
                Serial.print("Assertion failed: "); \
                Serial.println(message); \
                while(1); \
            } \
        } while(0)
#else
    #define GMINS_ASSERT(condition, message) ((void)0)
#endif
```

## 🔗 相關文件連結

### 開發標準
- [[5.實作指導/測試策略]] - 測試方法和品質保證
- [[5.實作指導/開發環境設置]] - 開發環境配置
- [[3.軟體架構重新設計/模組化設計方針]] - 模組化設計準則

### 架構文件
- [[3.軟體架構重新設計/新軟體架構設計]] - 整體軟體架構
- [[src目錄結構設計]] - 源代碼組織結構

---

**最後更新**: 2025-08-08  
**適用版本**: GMINS v2.0  
**維護者**: GMINS 開發團隊  
**編碼標準**: 基於 Google C++ Style Guide + Arduino 最佳實踐
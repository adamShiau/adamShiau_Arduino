# ç·¨ç¢¼è¦ç¯„

> **åŠŸèƒ½**: GMINS v2.0 å°ˆæ¡ˆç·¨ç¢¼é¢¨æ ¼å’Œé–‹ç™¼æ¨™æº–  
> **ç‰ˆæœ¬**: v2.0  
> **æœ€å¾Œæ›´æ–°**: 2025-08-08  
> **åŸºæ–¼æ¨™æº–**: Google C++ Style Guide + å°ˆæ¡ˆç‰¹å®šè¦å‰‡

## ğŸ¯ ç·¨ç¢¼åŸå‰‡

### æ ¸å¿ƒåŸå‰‡
1. **å¯è®€æ€§å„ªå…ˆ**: ä»£ç¢¼æ‡‰è©²æ˜“æ–¼é–±è®€å’Œç†è§£
2. **ä¸€è‡´æ€§**: ä¿æŒæ•´å€‹å°ˆæ¡ˆçš„é¢¨æ ¼ä¸€è‡´
3. **ç°¡æ½”æ€§**: é¿å…ä¸å¿…è¦çš„è¤‡é›œæ€§
4. **å¯ç¶­è­·æ€§**: ä¾¿æ–¼å¾ŒçºŒç¶­è­·å’Œæ“´å±•
5. **æ€§èƒ½è€ƒé‡**: åœ¨åµŒå…¥å¼ç’°å¢ƒä¸­æ³¨é‡æ€§èƒ½

## ğŸ“ å‘½åè¦ç¯„

### 1. æª”æ¡ˆå‘½å
```cpp
// æ¨™é ­æª” - å°å¯« + åº•ç·š
system_controller.h
communication_manager.h
fusion_engine.h

// å¯¦ä½œæª” - èˆ‡å°æ‡‰æ¨™é ­æª”åŒå
system_controller.cpp
communication_manager.cpp
fusion_engine.cpp

// æ¸¬è©¦æª” - test_ å‰ç¶´
test_system_controller.cpp
test_communication_manager.cpp
```

### 2. é¡åˆ¥å‘½å
```cpp
// é¡åˆ¥åç¨± - PascalCase
class SystemController {
public:
    // å…¬é–‹æˆå“¡å‡½æ•¸ - camelCase
    bool initialize();
    void processData();
    SystemState getCurrentState();
    
private:
    // ç§æœ‰æˆå“¡è®Šæ•¸ - åº•ç·šå¾Œç¶´
    SystemState current_state_;
    bool is_initialized_;
    uint32_t error_count_;
};

// çµæ§‹é«” - PascalCase
struct NavigationState {
    Vector3d position;
    Quaternion orientation;
    uint64_t timestamp_us;
};

// åˆ—èˆ‰ - å¤§å¯« + åº•ç·š
enum SystemState {
    STATE_UNINITIALIZED,
    STATE_INITIALIZING,
    STATE_RUNNING,
    STATE_ERROR
};
```

### 3. å‡½æ•¸å’Œè®Šæ•¸å‘½å
```cpp
// å‡½æ•¸ - camelCase
bool initializeSystem();
void processIncomingData();
float calculateDistance(const Vector3d& p1, const Vector3d& p2);

// å€åŸŸè®Šæ•¸ - camelCase
int sensorCount = 0;
float averageValue = 0.0f;
std::string errorMessage;

// å…¨åŸŸè®Šæ•¸ - g_ å‰ç¶´ (ç›¡é‡é¿å…ä½¿ç”¨)
extern bool g_systemInitialized;
extern int g_debugLevel;

// å¸¸æ•¸ - k å‰ç¶´ + PascalCase
static constexpr float kGravityAcceleration = 9.80665f;
static constexpr int kMaxSensorCount = 16;
static constexpr char kDefaultConfigFile[] = "gmins_config.txt";
```

### 4. å·¨é›†å®šç¾©
```cpp
// å·¨é›† - å…¨å¤§å¯« + åº•ç·š
#define GMINS_VERSION_MAJOR 2
#define GMINS_VERSION_MINOR 0
#define MAX_BUFFER_SIZE 1024

// æ¢ä»¶ç·¨è­¯ - å…¨å¤§å¯« + åº•ç·š
#ifdef DEBUG_MODE
    #define DEBUG_PRINT(msg) Serial.println(msg)
#else
    #define DEBUG_PRINT(msg)
#endif

// å‡½æ•¸å¼å·¨é›† - å…¨å¤§å¯« + åº•ç·š
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

## ğŸ—ï¸ ä»£ç¢¼æ ¼å¼

### 1. ç¸®æ’å’Œç©ºç™½
```cpp
// ä½¿ç”¨ 4 å€‹ç©ºæ ¼ç¸®æ’ï¼Œä¸ä½¿ç”¨ Tab
class ExampleClass {
public:
    ExampleClass() : member_var_(0) {
        // å»ºæ§‹å‡½æ•¸å…§å®¹
    }
    
    void exampleFunction() {
        if (condition) {
            // if å€å¡Šå…§å®¹
            for (int i = 0; i < count; ++i) {
                // for è¿´åœˆå…§å®¹
                processItem(i);
            }
        } else {
            // else å€å¡Šå…§å®¹
            handleError();
        }
    }
    
private:
    int member_var_;
};
```

### 2. å¤§æ‹¬è™Ÿé¢¨æ ¼
```cpp
// âœ… æ­£ç¢º - é–‹å¤§æ‹¬è™Ÿåœ¨åŒä¸€è¡Œ
if (condition) {
    // å…§å®¹
}

while (isRunning) {
    // å…§å®¹
}

class ClassName {
public:
    // å…§å®¹
};

// âŒ éŒ¯èª¤ - é–‹å¤§æ‹¬è™Ÿåœ¨æ–°è¡Œ (ä¸ä½¿ç”¨)
if (condition)
{
    // å…§å®¹
}
```

### 3. è¡Œé•·åº¦é™åˆ¶
```cpp
// æ¯è¡Œæœ€å¤š 100 å€‹å­—å…ƒ
// âœ… æ­£ç¢º
bool result = processData(sensor_data, configuration_params, 
                         error_handler, logger);

// âŒ éŒ¯èª¤ - è¶…é 100 å­—å…ƒ
bool result = processData(sensor_data, configuration_params, error_handler, logger, additional_param);

// é•·åƒæ•¸åˆ—è¡¨çš„è™•ç†
bool initializeSensors(
    const SensorConfig& imu_config,
    const SensorConfig& gps_config,
    const CommunicationConfig& comm_config,
    Logger* logger) {
    // å¯¦ä½œå…§å®¹
}
```

### 4. ç©ºè¡Œä½¿ç”¨
```cpp
#include <Arduino.h>
#include <vector>

#include "system_controller.h"
#include "communication_manager.h"

namespace gmins {

class ExampleClass {
public:
    ExampleClass();
    ~ExampleClass();
    
    void initialize();
    void process();
    
private:
    void internalFunction();
    
    int member_variable_;
};

}  // namespace gmins
```

## ğŸ“š ä»£ç¢¼çµ„ç¹”

### 1. æ¨™é ­æª”çµæ§‹
```cpp
// system_controller.h
#ifndef GMINS_CORE_SYSTEM_CONTROLLER_H_
#define GMINS_CORE_SYSTEM_CONTROLLER_H_

// ç³»çµ±æ¨™é ­æª”
#include <memory>
#include <vector>

// å°ˆæ¡ˆæ¨™é ­æª”
#include "communication/comm_manager.h"
#include "data/data_types.h"
#include "utils/logger.h"

namespace gmins {
namespace core {

// å‰å‘å®£å‘Š
class FusionEngine;
class SafetyGuardian;

/**
 * @brief ç³»çµ±æ§åˆ¶å™¨é¡åˆ¥
 * 
 * è² è²¬æ•´å€‹ GMINS ç³»çµ±çš„ç”Ÿå‘½é€±æœŸç®¡ç†å’Œæ¨¡çµ„å”èª¿ã€‚
 * 
 * @details
 * æ­¤é¡åˆ¥æ˜¯ GMINS ç³»çµ±çš„æ ¸å¿ƒæ§åˆ¶å™¨ï¼Œè² è²¬ï¼š
 * - ç³»çµ±åˆå§‹åŒ–å’Œé—œé–‰
 * - æ¨¡çµ„é–“å”èª¿
 * - ç³»çµ±ç‹€æ…‹ç®¡ç†
 * - éŒ¯èª¤è™•ç†å’Œæ¢å¾©
 */
class SystemController {
public:
    /**
     * @brief ç³»çµ±ç‹€æ…‹åˆ—èˆ‰
     */
    enum SystemState {
        STATE_UNINITIALIZED = 0,  ///< æœªåˆå§‹åŒ–ç‹€æ…‹
        STATE_INITIALIZING = 1,   ///< æ­£åœ¨åˆå§‹åŒ–
        STATE_READY = 2,          ///< æº–å‚™å°±ç·’
        STATE_RUNNING = 3,        ///< æ­£å¸¸é‹è¡Œ
        STATE_ERROR = 4,          ///< éŒ¯èª¤ç‹€æ…‹
        STATE_SHUTDOWN = 5        ///< é—œé–‰ç‹€æ…‹
    };
    
    /**
     * @brief å»ºæ§‹å‡½æ•¸
     * @param logger æ—¥èªŒè¨˜éŒ„å™¨æŒ‡æ¨™
     */
    explicit SystemController(Logger* logger);
    
    /**
     * @brief è§£æ§‹å‡½æ•¸
     */
    ~SystemController();
    
    /**
     * @brief åˆå§‹åŒ–ç³»çµ±
     * @return true åˆå§‹åŒ–æˆåŠŸï¼Œfalse åˆå§‹åŒ–å¤±æ•—
     */
    bool initialize();
    
    /**
     * @brief ä¸»è¦é‹è¡Œè¿´åœˆ
     */
    void run();
    
    /**
     * @brief é—œé–‰ç³»çµ±
     */
    void shutdown();
    
    /**
     * @brief ç²å–ç•¶å‰ç³»çµ±ç‹€æ…‹
     * @return ç•¶å‰ç³»çµ±ç‹€æ…‹
     */
    SystemState getState() const { return current_state_; }
    
private:
    // ä¸å…è¨±è¤‡è£½å’Œè³¦å€¼
    SystemController(const SystemController&) = delete;
    SystemController& operator=(const SystemController&) = delete;
    
    /**
     * @brief åˆå§‹åŒ–å­ç³»çµ±
     * @return true æˆåŠŸï¼Œfalse å¤±æ•—
     */
    bool initializeSubsystems();
    
    /**
     * @brief å”èª¿å„æ¨¡çµ„é‹ä½œ
     */
    void coordinateModules();
    
    SystemState current_state_;
    Logger* logger_;
    std::unique_ptr<CommunicationManager> comm_manager_;
    std::unique_ptr<FusionEngine> fusion_engine_;
    std::unique_ptr<SafetyGuardian> safety_guardian_;
};

}  // namespace core
}  // namespace gmins

#endif  // GMINS_CORE_SYSTEM_CONTROLLER_H_
```

### 2. å¯¦ä½œæª”çµæ§‹
```cpp
// system_controller.cpp
#include "core/system_controller.h"

#include <Arduino.h>

#include "core/fusion_engine.h"
#include "core/safety_guardian.h"
#include "utils/logger.h"

namespace gmins {
namespace core {

namespace {
// åŒ¿åå‘½åç©ºé–“ä¸­çš„å…§éƒ¨å¸¸æ•¸å’Œå‡½æ•¸
constexpr uint32_t kInitializationTimeoutMs = 5000;
constexpr uint32_t kHeartbeatIntervalMs = 1000;

bool validateSystemConfiguration() {
    // å…§éƒ¨è¼”åŠ©å‡½æ•¸
    return true;
}
}  // anonymous namespace

SystemController::SystemController(Logger* logger)
    : current_state_(STATE_UNINITIALIZED)
    , logger_(logger) {
    if (logger_ == nullptr) {
        // ä½¿ç”¨é è¨­æ—¥èªŒå™¨
        logger_ = Logger::getInstance();
    }
}

SystemController::~SystemController() {
    if (current_state_ != STATE_SHUTDOWN) {
        shutdown();
    }
}

bool SystemController::initialize() {
    logger_->log(LogLevel::INFO, "Starting system initialization");
    
    current_state_ = STATE_INITIALIZING;
    
    if (!validateSystemConfiguration()) {
        logger_->log(LogLevel::ERROR, "System configuration validation failed");
        current_state_ = STATE_ERROR;
        return false;
    }
    
    if (!initializeSubsystems()) {
        logger_->log(LogLevel::ERROR, "Subsystem initialization failed");
        current_state_ = STATE_ERROR;
        return false;
    }
    
    current_state_ = STATE_READY;
    logger_->log(LogLevel::INFO, "System initialization completed successfully");
    return true;
}

void SystemController::run() {
    if (current_state_ != STATE_READY) {
        logger_->log(LogLevel::WARNING, "System not ready for operation");
        return;
    }
    
    current_state_ = STATE_RUNNING;
    logger_->log(LogLevel::INFO, "System started running");
    
    while (current_state_ == STATE_RUNNING) {
        coordinateModules();
        
        // ç°¡å–®çš„å»¶é²æ§åˆ¶
        delay(1);  // 1ms å»¶é²
    }
}

bool SystemController::initializeSubsystems() {
    // å‰µå»ºé€šè¨Šç®¡ç†å™¨
    comm_manager_ = std::make_unique<CommunicationManager>(logger_);
    if (!comm_manager_->initialize()) {
        return false;
    }
    
    // å‰µå»ºèåˆå¼•æ“
    fusion_engine_ = std::make_unique<FusionEngine>(logger_);
    if (!fusion_engine_->initialize()) {
        return false;
    }
    
    // å‰µå»ºå®‰å…¨å®ˆè­·
    safety_guardian_ = std::make_unique<SafetyGuardian>(logger_);
    if (!safety_guardian_->initialize()) {
        return false;
    }
    
    return true;
}

void SystemController::coordinateModules() {
    // è™•ç†é€šè¨Š
    comm_manager_->processIncomingData();
    
    // è™•ç†æ„Ÿæ¸¬å™¨èåˆ
    if (comm_manager_->hasNewSensorData()) {
        auto sensor_data = comm_manager_->getLatestSensorData();
        fusion_engine_->processSensorData(sensor_data);
    }
    
    // å®‰å…¨æª¢æŸ¥
    if (!safety_guardian_->checkSystemSafety()) {
        logger_->log(LogLevel::WARNING, "Safety check failed");
        current_state_ = STATE_ERROR;
    }
    
    // ç™¼é€å°èˆªç‹€æ…‹
    auto nav_state = fusion_engine_->getNavigationState();
    comm_manager_->sendNavigationState(nav_state);
}

void SystemController::shutdown() {
    logger_->log(LogLevel::INFO, "Starting system shutdown");
    
    current_state_ = STATE_SHUTDOWN;
    
    // æŒ‰ç›¸åé †åºé—œé–‰å­ç³»çµ±
    safety_guardian_.reset();
    fusion_engine_.reset();
    comm_manager_.reset();
    
    logger_->log(LogLevel::INFO, "System shutdown completed");
}

}  // namespace core
}  // namespace gmins
```

## ğŸ’¬ è¨»é‡‹è¦ç¯„

### 1. æ–‡ä»¶è¨»é‡‹
```cpp
/**
 * @file system_controller.h
 * @brief GMINS ç³»çµ±æ§åˆ¶å™¨å®šç¾©
 * @author GMINS é–‹ç™¼åœ˜éšŠ
 * @date 2025-08-08
 * @version 2.0
 * 
 * æ­¤æª”æ¡ˆåŒ…å« GMINS ç³»çµ±çš„æ ¸å¿ƒæ§åˆ¶å™¨é¡åˆ¥å®šç¾©ï¼Œ
 * è² è²¬æ•´å€‹ç³»çµ±çš„ç”Ÿå‘½é€±æœŸç®¡ç†å’Œæ¨¡çµ„å”èª¿ã€‚
 */
```

### 2. é¡åˆ¥å’Œå‡½æ•¸è¨»é‡‹
```cpp
/**
 * @brief è¨ˆç®—å…©é»é–“çš„è·é›¢
 * 
 * ä½¿ç”¨æ­å¹¾é‡Œå¾—è·é›¢å…¬å¼è¨ˆç®—ä¸‰ç¶­ç©ºé–“ä¸­å…©é»é–“çš„è·é›¢ã€‚
 * 
 * @param p1 ç¬¬ä¸€å€‹é»çš„åº§æ¨™
 * @param p2 ç¬¬äºŒå€‹é»çš„åº§æ¨™
 * @return float å…©é»é–“çš„è·é›¢ï¼ˆå–®ä½ï¼šç±³ï¼‰
 * 
 * @note æ­¤å‡½æ•¸å‡è¨­è¼¸å…¥åº§æ¨™ä½¿ç”¨ç›¸åŒçš„åº§æ¨™ç³»çµ±
 * @warning ç•¶è¼¸å…¥å‘é‡åŒ…å« NaN æˆ–ç„¡çª®å¤§æ™‚ï¼Œçµæœæœªå®šç¾©
 * 
 * @code
 * Vector3d point1{0.0, 0.0, 0.0};
 * Vector3d point2{1.0, 1.0, 1.0};
 * float distance = calculateDistance(point1, point2);
 * // distance = 1.732 (approximately)
 * @endcode
 */
float calculateDistance(const Vector3d& p1, const Vector3d& p2);
```

### 3. è¡Œå…§è¨»é‡‹
```cpp
void processData() {
    // æª¢æŸ¥è³‡æ–™æœ‰æ•ˆæ€§
    if (!isDataValid()) {
        return;  // æ—©æœŸè¿”å›ï¼Œé¿å…è™•ç†ç„¡æ•ˆè³‡æ–™
    }
    
    float average = 0.0f;
    for (int i = 0; i < data_count; ++i) {
        average += data_array[i];  // ç´¯åŠ æ‰€æœ‰æ•¸å€¼
    }
    average /= data_count;  // è¨ˆç®—å¹³å‡å€¼
    
    /* 
     * è¤‡é›œçš„è™•ç†é‚è¼¯èªªæ˜ï¼š
     * 1. é¦–å…ˆé€²è¡Œä½é€šæ¿¾æ³¢
     * 2. ç„¶å¾Œæ‡‰ç”¨å¡çˆ¾æ›¼æ¿¾æ³¢
     * 3. æœ€å¾Œé€²è¡Œæ•¸å€¼ç©©å®šåŒ–
     */
    average = applyLowPassFilter(average);
    average = applyKalmanFilter(average);
    average = stabilizeValue(average);
}
```

## ğŸš¨ éŒ¯èª¤è™•ç†

### 1. ç•°å¸¸å®‰å…¨
```cpp
// âœ… è‰¯å¥½çš„è³‡æºç®¡ç†
class ResourceManager {
public:
    bool initialize() {
        // ä½¿ç”¨ RAII ç®¡ç†è³‡æº
        file_handle_ = std::make_unique<FileHandle>();
        if (!file_handle_->open("config.txt")) {
            return false;  // è‡ªå‹•æ¸…ç†
        }
        
        memory_buffer_ = std::make_unique<uint8_t[]>(1024);
        return true;
    }
    
private:
    std::unique_ptr<FileHandle> file_handle_;
    std::unique_ptr<uint8_t[]> memory_buffer_;
};

// âœ… éŒ¯èª¤ç¢¼è¿”å›
enum class ErrorCode {
    SUCCESS = 0,
    INVALID_PARAMETER,
    INSUFFICIENT_MEMORY,
    HARDWARE_ERROR,
    TIMEOUT
};

ErrorCode processData(const SensorData& data, ProcessedData* result) {
    if (result == nullptr) {
        return ErrorCode::INVALID_PARAMETER;
    }
    
    if (!isValidData(data)) {
        return ErrorCode::INVALID_PARAMETER;
    }
    
    if (!allocateMemory()) {
        return ErrorCode::INSUFFICIENT_MEMORY;
    }
    
    // è™•ç†é‚è¼¯
    *result = computeResult(data);
    return ErrorCode::SUCCESS;
}
```

### 2. æ–·è¨€ä½¿ç”¨
```cpp
#include <cassert>

// é–‹ç™¼æ™‚çš„æ–·è¨€æª¢æŸ¥
void processArray(const float* array, size_t size) {
    assert(array != nullptr);    // åƒæ•¸é©—è­‰
    assert(size > 0);            // å¤§å°é©—è­‰
    assert(size <= MAX_SIZE);    // é‚Šç•Œæª¢æŸ¥
    
    for (size_t i = 0; i < size; ++i) {
        assert(!std::isnan(array[i]));  // æ•¸å€¼æœ‰æ•ˆæ€§æª¢æŸ¥
        // è™•ç†é‚è¼¯
    }
}

// è‡ªå®šç¾©æ–·è¨€å·¨é›†
#ifdef DEBUG_MODE
    #define GMINS_ASSERT(condition, message) \
        do { \
            if (!(condition)) { \
                Serial.print("Assertion failed: "); \
                Serial.println(message); \
                while(1); \
            } \
        } while(0)
#else
    #define GMINS_ASSERT(condition, message) ((void)0)
#endif
```

## ğŸ”— ç›¸é—œæ–‡ä»¶é€£çµ

### é–‹ç™¼æ¨™æº–
- [[5.å¯¦ä½œæŒ‡å°/æ¸¬è©¦ç­–ç•¥]] - æ¸¬è©¦æ–¹æ³•å’Œå“è³ªä¿è­‰
- [[5.å¯¦ä½œæŒ‡å°/é–‹ç™¼ç’°å¢ƒè¨­ç½®]] - é–‹ç™¼ç’°å¢ƒé…ç½®
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/æ¨¡çµ„åŒ–è¨­è¨ˆæ–¹é‡]] - æ¨¡çµ„åŒ–è¨­è¨ˆæº–å‰‡

### æ¶æ§‹æ–‡ä»¶
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/æ–°è»Ÿé«”æ¶æ§‹è¨­è¨ˆ]] - æ•´é«”è»Ÿé«”æ¶æ§‹
- [[srcç›®éŒ„çµæ§‹è¨­è¨ˆ]] - æºä»£ç¢¼çµ„ç¹”çµæ§‹

---

**æœ€å¾Œæ›´æ–°**: 2025-08-08  
**é©ç”¨ç‰ˆæœ¬**: GMINS v2.0  
**ç¶­è­·è€…**: GMINS é–‹ç™¼åœ˜éšŠ  
**ç·¨ç¢¼æ¨™æº–**: åŸºæ–¼ Google C++ Style Guide + Arduino æœ€ä½³å¯¦è¸
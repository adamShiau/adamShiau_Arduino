# æ¸¬è©¦ç­–ç•¥

> **åŠŸèƒ½**: GMINS v2.0 å…¨é¢æ¸¬è©¦ç­–ç•¥å’Œå“è³ªä¿è­‰æ–¹æ¡ˆ  
> **ç‰ˆæœ¬**: v2.0  
> **æœ€å¾Œæ›´æ–°**: 2025-08-08  
> **æ¸¬è©¦æ¡†æ¶**: Unity + è‡ªå®šç¾©æ¸¬è©¦å·¥å…·

## ğŸ¯ æ¸¬è©¦ç›®æ¨™

### å“è³ªä¿è­‰ç›®æ¨™
1. **åŠŸèƒ½æ­£ç¢ºæ€§**: ç¢ºä¿æ‰€æœ‰åŠŸèƒ½æŒ‰è¦æ ¼æ­£å¸¸å·¥ä½œ
2. **å¯é æ€§**: ç³»çµ±èƒ½å¤ ç©©å®šé‹è¡Œ 24/7
3. **æ€§èƒ½é”æ¨™**: æ»¿è¶³å³æ™‚æ€§èƒ½è¦æ±‚
4. **å®‰å…¨æ€§**: ç¢ºä¿ç³»çµ±åœ¨å„ç¨®æƒ…æ³ä¸‹çš„å®‰å…¨é‹è¡Œ
5. **å¯ç¶­è­·æ€§**: ä¾¿æ–¼å¾ŒçºŒé–‹ç™¼å’Œç¶­è­·

### æ¸¬è©¦è¦†è“‹ç‡ç›®æ¨™
- **å–®å…ƒæ¸¬è©¦è¦†è“‹ç‡**: > 90%
- **æ•´åˆæ¸¬è©¦è¦†è“‹ç‡**: > 85%
- **ç³»çµ±æ¸¬è©¦è¦†è“‹ç‡**: > 80%
- **å®‰å…¨æ¸¬è©¦è¦†è“‹ç‡**: 100% (é—œéµå®‰å…¨åŠŸèƒ½)

## ğŸ—ï¸ æ¸¬è©¦æ¶æ§‹

### æ¸¬è©¦é‡‘å­—å¡”
```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   ç³»çµ±æ¸¬è©¦      â”‚  (å°‘é‡)
                    â”‚ System Tests    â”‚  è¤‡é›œã€æ…¢é€Ÿã€é«˜åƒ¹å€¼
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚    æ•´åˆæ¸¬è©¦       â”‚  (ä¸­ç­‰)
                   â”‚ Integration Tests â”‚  ä¸­ç­‰è¤‡é›œåº¦ã€ä¸­ç­‰é€Ÿåº¦
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚        å–®å…ƒæ¸¬è©¦          â”‚  (å¤§é‡)
              â”‚     Unit Tests           â”‚  ç°¡å–®ã€å¿«é€Ÿã€ä½æˆæœ¬
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ¸¬è©¦å±¤ç´šåŠƒåˆ†

#### 1. å–®å…ƒæ¸¬è©¦ (Unit Tests)
- **ç¯„åœ**: å€‹åˆ¥å‡½æ•¸å’Œé¡åˆ¥æ–¹æ³•
- **ç›®æ¨™**: é©—è­‰æœ€å°å¯æ¸¬è©¦å–®å…ƒçš„æ­£ç¢ºæ€§
- **å·¥å…·**: Unity Test Framework
- **åŸ·è¡Œé »ç‡**: æ¯æ¬¡ç¨‹å¼ç¢¼è®Šæ›´

#### 2. æ•´åˆæ¸¬è©¦ (Integration Tests)
- **ç¯„åœ**: æ¨¡çµ„é–“ä»‹é¢å’Œè³‡æ–™æµ
- **ç›®æ¨™**: é©—è­‰æ¨¡çµ„é–“çš„å”ä½œæ­£ç¢ºæ€§
- **å·¥å…·**: Unity + Mock Objects
- **åŸ·è¡Œé »ç‡**: æ¯æ—¥è‡ªå‹•åŸ·è¡Œ

#### 3. ç³»çµ±æ¸¬è©¦ (System Tests)
- **ç¯„åœ**: å®Œæ•´ç³»çµ±åŠŸèƒ½
- **ç›®æ¨™**: é©—è­‰ç³»çµ±æ•´é«”åŠŸèƒ½å’Œæ€§èƒ½
- **å·¥å…·**: ç¡¬é«”åœ¨ç’°æ¸¬è©¦ (HIL)
- **åŸ·è¡Œé »ç‡**: æ¯é€±åŸ·è¡Œ

#### 4. é©—æ”¶æ¸¬è©¦ (Acceptance Tests)
- **ç¯„åœ**: ä½¿ç”¨è€…éœ€æ±‚å’Œç”¨ä¾‹
- **ç›®æ¨™**: ç¢ºä¿æ»¿è¶³ä½¿ç”¨è€…éœ€æ±‚
- **å·¥å…·**: å¯¦éš›ç¡¬é«”æ¸¬è©¦
- **åŸ·è¡Œé »ç‡**: ç™¼å¸ƒå‰åŸ·è¡Œ

## ğŸ§ª å–®å…ƒæ¸¬è©¦ç­–ç•¥

### æ¸¬è©¦æ¡†æ¶è¨­ç½®
```cpp
// tests/test_config.h
#ifndef TEST_CONFIG_H_
#define TEST_CONFIG_H_

#include <unity.h>
#include <memory>

// æ¸¬è©¦è¼”åŠ©å·¨é›†
#define TEST_ASSERT_FLOAT_WITHIN_RANGE(expected, actual, tolerance) \
    TEST_ASSERT_FLOAT_WITHIN(tolerance, expected, actual)

#define TEST_ASSERT_VECTOR3_EQUAL(expected, actual, tolerance) \
    do { \
        TEST_ASSERT_FLOAT_WITHIN(tolerance, expected.x, actual.x); \
        TEST_ASSERT_FLOAT_WITHIN(tolerance, expected.y, actual.y); \
        TEST_ASSERT_FLOAT_WITHIN(tolerance, expected.z, actual.z); \
    } while(0)

// æ¸¬è©¦å¤¾å…·åŸºé¡
class TestFixture {
public:
    virtual void setUp() {}
    virtual void tearDown() {}
    
protected:
    // é€šç”¨æ¸¬è©¦å·¥å…·
    bool compareFloats(float a, float b, float epsilon = 1e-6f) {
        return std::abs(a - b) < epsilon;
    }
    
    void printTestResult(const char* test_name, bool passed) {
        Serial.print(test_name);
        Serial.print(": ");
        Serial.println(passed ? "PASSED" : "FAILED");
    }
};

#endif  // TEST_CONFIG_H_
```

### æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦ç¯„ä¾‹

#### FusionEngine å–®å…ƒæ¸¬è©¦
```cpp
// tests/unit_tests/test_fusion_engine.cpp
#include "test_config.h"
#include "core/fusion_engine.h"
#include "mocks/mock_logger.h"

using namespace gmins::core;

class FusionEngineTest : public TestFixture {
public:
    void setUp() override {
        mock_logger_ = std::make_unique<MockLogger>();
        fusion_engine_ = std::make_unique<FusionEngine>(mock_logger_.get());
    }
    
    void tearDown() override {
        fusion_engine_.reset();
        mock_logger_.reset();
    }
    
protected:
    std::unique_ptr<MockLogger> mock_logger_;
    std::unique_ptr<FusionEngine> fusion_engine_;
    
    // æ¸¬è©¦è³‡æ–™ç”Ÿæˆ
    SensorDataPacket createTestSensorData() {
        SensorDataPacket data;
        data.timestamp_us = 1000000;  // 1 second
        
        // IMU æ¸¬è©¦è³‡æ–™
        data.imu_data.orientation = Quaternion(1.0f, 0.0f, 0.0f, 0.0f);
        data.imu_data.angular_velocity = Vector3f(0.1f, 0.2f, 0.3f);
        data.imu_data.acceleration = Vector3f(0.0f, 0.0f, -9.81f);
        data.has_imu_data = true;
        
        // GPS æ¸¬è©¦è³‡æ–™
        data.gps_data.latitude = 25.0330;   // å°åŒ—
        data.gps_data.longitude = 121.5654;
        data.gps_data.altitude = 100.0f;
        data.gps_data.velocity = Vector3f(1.0f, 0.0f, 0.0f);
        data.gps_data.satellites_used = 8;
        data.gps_data.hdop = 1.2f;
        data.has_gps_data = true;
        
        return data;
    }
};

// æ¸¬è©¦ç”¨ä¾‹
void test_fusion_engine_initialization(void) {
    FusionEngineTest test;
    test.setUp();
    
    FusionConfig config;
    bool result = test.fusion_engine_->initialize(config);
    
    TEST_ASSERT_TRUE(result);
    TEST_ASSERT_EQUAL(FusionEngine::STATE_READY, 
                      test.fusion_engine_->getState());
    
    test.tearDown();
}

void test_sensor_data_processing(void) {
    FusionEngineTest test;
    test.setUp();
    
    // åˆå§‹åŒ–èåˆå¼•æ“
    FusionConfig config;
    test.fusion_engine_->initialize(config);
    
    // è™•ç†æ¸¬è©¦è³‡æ–™
    SensorDataPacket test_data = test.createTestSensorData();
    test.fusion_engine_->processSensorData(test_data);
    
    // é©—è­‰çµæœ
    NavigationState nav_state = test.fusion_engine_->getNavigationState();
    
    TEST_ASSERT_TRUE(nav_state.timestamp_us > 0);
    TEST_ASSERT_FLOAT_WITHIN(0.001, 25.0330, nav_state.position_llh.latitude);
    TEST_ASSERT_FLOAT_WITHIN(0.001, 121.5654, nav_state.position_llh.longitude);
    
    test.tearDown();
}

void test_dynamic_weights_update(void) {
    FusionEngineTest test;
    test.setUp();
    
    FusionConfig config;
    test.fusion_engine_->initialize(config);
    
    // æ¸¬è©¦éœæ­¢ç‹€æ…‹
    MotionState static_motion;
    static_motion.velocity_magnitude = 0.0f;
    static_motion.acceleration_magnitude = 0.0f;
    static_motion.angular_rate_magnitude = 0.0f;
    
    test.fusion_engine_->updateDynamicWeights(static_motion);
    DynamicWeights weights = test.fusion_engine_->getCurrentWeights();
    
    // éœæ­¢æ™‚æ‡‰è©²æ›´ä¿¡ä»» GNSS
    TEST_ASSERT_GREATER_THAN(0.5f, weights.gnss_position_weight);
    TEST_ASSERT_LESS_THAN(0.5f, weights.imu_position_weight);
    
    test.tearDown();
}

void test_coordinate_transformation(void) {
    FusionEngineTest test;
    test.setUp();
    
    // æ¸¬è©¦ LLH åˆ° ENU è½‰æ›
    LLHPosition origin{25.0330, 121.5654, 100.0};
    LLHPosition target{25.0340, 121.5664, 110.0};
    
    Vector3d enu_pos = test.fusion_engine_->llhToEnu(target, origin);
    
    // é©—è­‰è½‰æ›çµæœåˆç†æ€§
    TEST_ASSERT_GREATER_THAN(0.0, enu_pos.x);  // å‘æ±
    TEST_ASSERT_GREATER_THAN(0.0, enu_pos.y);  // å‘åŒ—  
    TEST_ASSERT_FLOAT_WITHIN(1.0, 10.0, enu_pos.z);  // å‘ä¸Š 10m
    
    test.tearDown();
}

// æ¸¬è©¦åŸ·è¡Œå™¨
void runFusionEngineTests() {
    UNITY_BEGIN();
    
    RUN_TEST(test_fusion_engine_initialization);
    RUN_TEST(test_sensor_data_processing);
    RUN_TEST(test_dynamic_weights_update);
    RUN_TEST(test_coordinate_transformation);
    
    UNITY_END();
}
```

### Mock ç‰©ä»¶å¯¦ä½œ
```cpp
// tests/mocks/mock_logger.h
#ifndef MOCK_LOGGER_H_
#define MOCK_LOGGER_H_

#include "utils/logger.h"
#include <vector>
#include <string>

class MockLogger : public Logger {
public:
    struct LogEntry {
        LogLevel level;
        std::string message;
        uint32_t timestamp;
    };
    
    void log(LogLevel level, const std::string& message) override {
        LogEntry entry;
        entry.level = level;
        entry.message = message;
        entry.timestamp = millis();
        log_entries_.push_back(entry);
    }
    
    // æ¸¬è©¦è¼”åŠ©æ–¹æ³•
    size_t getLogCount() const { return log_entries_.size(); }
    
    size_t getLogCount(LogLevel level) const {
        size_t count = 0;
        for (const auto& entry : log_entries_) {
            if (entry.level == level) {
                count++;
            }
        }
        return count;
    }
    
    bool hasLogMessage(const std::string& message) const {
        for (const auto& entry : log_entries_) {
            if (entry.message.find(message) != std::string::npos) {
                return true;
            }
        }
        return false;
    }
    
    void clearLogs() {
        log_entries_.clear();
    }
    
    const std::vector<LogEntry>& getLogs() const {
        return log_entries_;
    }
    
private:
    std::vector<LogEntry> log_entries_;
};

#endif  // MOCK_LOGGER_H_
```

## ğŸ”— æ•´åˆæ¸¬è©¦ç­–ç•¥

### æ¨¡çµ„é–“é€šè¨Šæ¸¬è©¦
```cpp
// tests/integration_tests/test_comm_fusion_integration.cpp
#include "test_config.h"
#include "communication/comm_manager.h"
#include "core/fusion_engine.h"
#include "mocks/mock_uart.h"

class CommFusionIntegrationTest : public TestFixture {
public:
    void setUp() override {
        mock_uart_ = std::make_unique<MockUART>();
        mock_logger_ = std::make_unique<MockLogger>();
        
        comm_manager_ = std::make_unique<CommunicationManager>(mock_logger_.get());
        fusion_engine_ = std::make_unique<FusionEngine>(mock_logger_.get());
        
        // è¨­ç½®æ¨¡æ“¬ UART
        comm_manager_->setUARTInterface(CHANNEL_MTI680, mock_uart_.get());
    }
    
    void tearDown() override {
        fusion_engine_.reset();
        comm_manager_.reset();
        mock_logger_.reset();
        mock_uart_.reset();
    }
    
protected:
    std::unique_ptr<MockUART> mock_uart_;
    std::unique_ptr<MockLogger> mock_logger_;
    std::unique_ptr<CommunicationManager> comm_manager_;
    std::unique_ptr<FusionEngine> fusion_engine_;
};

void test_sensor_data_flow(void) {
    CommFusionIntegrationTest test;
    test.setUp();
    
    // æº–å‚™æ¨¡æ“¬ XBUS è³‡æ–™
    uint8_t xbus_packet[] = {
        0xFA, 0xFF,  // XBUS preamble
        0x36, 0x00,  // Message ID and length
        // ... XBUS payload ...
        0x00, 0x00   // Checksum
    };
    
    // è¨­ç½®æ¨¡æ“¬ UART æ¥æ”¶è³‡æ–™
    test.mock_uart_->setIncomingData(xbus_packet, sizeof(xbus_packet));
    
    // åˆå§‹åŒ–ç³»çµ±
    test.comm_manager_->initialize();
    test.fusion_engine_->initialize(FusionConfig{});
    
    // è™•ç†è³‡æ–™
    test.comm_manager_->processIncomingData();
    
    // é©—è­‰é€šè¨Šç®¡ç†å™¨æ˜¯å¦æ­£ç¢ºè§£æè³‡æ–™
    TEST_ASSERT_TRUE(test.comm_manager_->hasNewSensorData());
    
    SensorDataPacket sensor_data = test.comm_manager_->getLatestSensorData();
    TEST_ASSERT_TRUE(sensor_data.has_imu_data);
    
    // å°‡è³‡æ–™å‚³éçµ¦èåˆå¼•æ“
    test.fusion_engine_->processSensorData(sensor_data);
    
    // é©—è­‰èåˆå¼•æ“æ˜¯å¦æ­£ç¢ºè™•ç†è³‡æ–™
    NavigationState nav_state = test.fusion_engine_->getNavigationState();
    TEST_ASSERT_TRUE(nav_state.timestamp_us > 0);
    
    test.tearDown();
}
```

## ğŸ­ ç³»çµ±æ¸¬è©¦ç­–ç•¥

### ç¡¬é«”åœ¨ç’° (HIL) æ¸¬è©¦
```cpp
// tests/system_tests/test_complete_system.cpp
class CompleteSystemTest : public TestFixture {
public:
    void setUp() override {
        // è¨­ç½®å®Œæ•´çš„ç¡¬é«”ç’°å¢ƒ
        setupHardware();
        
        system_controller_ = std::make_unique<SystemController>(
            Logger::getInstance());
    }
    
    void tearDown() override {
        system_controller_->shutdown();
        system_controller_.reset();
        cleanupHardware();
    }
    
private:
    void setupHardware() {
        // åˆå§‹åŒ–çœŸå¯¦çš„ UART ä»‹é¢
        Serial1.begin(460800);  // Pixhawk
        Serial2.begin(115200);  // MTi-680
        Serial3.begin(115200);  // NMEA Out
        Serial4.begin(115200);  // NMEA In
        
        delay(1000);  // ç­‰å¾…ç¡¬é«”ç©©å®š
    }
    
    void cleanupHardware() {
        Serial1.end();
        Serial2.end();
        Serial3.end();
        Serial4.end();
    }
    
    std::unique_ptr<SystemController> system_controller_;
};

void test_complete_system_startup(void) {
    CompleteSystemTest test;
    test.setUp();
    
    // æ¸¬è©¦ç³»çµ±å•Ÿå‹•
    bool init_result = test.system_controller_->initialize();
    TEST_ASSERT_TRUE(init_result);
    TEST_ASSERT_EQUAL(SystemController::STATE_READY, 
                      test.system_controller_->getState());
    
    // é‹è¡Œç³»çµ±ä¸€æ®µæ™‚é–“
    unsigned long start_time = millis();
    unsigned long test_duration = 5000;  // 5 seconds
    
    while (millis() - start_time < test_duration) {
        test.system_controller_->update();
        delay(10);
    }
    
    // é©—è­‰ç³»çµ±ç‹€æ…‹
    TEST_ASSERT_EQUAL(SystemController::STATE_RUNNING, 
                      test.system_controller_->getState());
    
    test.tearDown();
}

void test_sensor_data_processing_end_to_end(void) {
    CompleteSystemTest test;
    test.setUp();
    
    test.system_controller_->initialize();
    
    // æ¨¡æ“¬æ„Ÿæ¸¬å™¨è³‡æ–™è¼¸å…¥ä¸¦é©—è­‰ MAVLink è¼¸å‡º
    unsigned long start_time = millis();
    bool mavlink_received = false;
    
    while (millis() - start_time < 10000 && !mavlink_received) {  // 10 seconds timeout
        test.system_controller_->update();
        
        // æª¢æŸ¥æ˜¯å¦æœ‰ MAVLink è¼¸å‡º
        if (Serial1.available()) {
            // ç°¡å–®æª¢æŸ¥æ˜¯å¦ç‚ºæœ‰æ•ˆçš„ MAVLink å°åŒ…
            uint8_t byte = Serial1.read();
            if (byte == MAVLINK_STX) {  // MAVLink start byte
                mavlink_received = true;
            }
        }
        
        delay(1);
    }
    
    TEST_ASSERT_TRUE(mavlink_received);
    
    test.tearDown();
}
```

## ğŸ“Š æ€§èƒ½æ¸¬è©¦

### å³æ™‚æ€§èƒ½æ¸¬è©¦
```cpp
// tests/performance_tests/test_performance.cpp
class PerformanceTest : public TestFixture {
public:
    struct PerformanceMetrics {
        uint32_t max_processing_time_us;
        uint32_t avg_processing_time_us;
        uint32_t min_processing_time_us;
        uint32_t sample_count;
    };
    
    void measurePerformance(std::function<void()> test_function, 
                           PerformanceMetrics& metrics,
                           uint32_t iterations = 1000) {
        uint32_t total_time = 0;
        metrics.max_processing_time_us = 0;
        metrics.min_processing_time_us = UINT32_MAX;
        metrics.sample_count = iterations;
        
        for (uint32_t i = 0; i < iterations; ++i) {
            uint32_t start_time = micros();
            test_function();
            uint32_t end_time = micros();
            
            uint32_t duration = end_time - start_time;
            total_time += duration;
            
            if (duration > metrics.max_processing_time_us) {
                metrics.max_processing_time_us = duration;
            }
            if (duration < metrics.min_processing_time_us) {
                metrics.min_processing_time_us = duration;
            }
            
            delay(1);  // é¿å…é€£çºŒæ¸¬é‡çš„å¹²æ“¾
        }
        
        metrics.avg_processing_time_us = total_time / iterations;
    }
};

void test_fusion_engine_performance(void) {
    PerformanceTest test;
    test.setUp();
    
    MockLogger mock_logger;
    FusionEngine fusion_engine(&mock_logger);
    fusion_engine.initialize(FusionConfig{});
    
    SensorDataPacket test_data = createRealisticSensorData();
    
    PerformanceTest::PerformanceMetrics metrics;
    test.measurePerformance([&]() {
        fusion_engine.processSensorData(test_data);
    }, metrics);
    
    // æ€§èƒ½è¦æ±‚é©—è­‰
    TEST_ASSERT_LESS_THAN(5000, metrics.max_processing_time_us);  // < 5ms
    TEST_ASSERT_LESS_THAN(2000, metrics.avg_processing_time_us);  // < 2ms
    
    Serial.println("=== Fusion Engine Performance ===");
    Serial.printf("Max: %u us\n", metrics.max_processing_time_us);
    Serial.printf("Avg: %u us\n", metrics.avg_processing_time_us);
    Serial.printf("Min: %u us\n", metrics.min_processing_time_us);
    
    test.tearDown();
}
```

## ğŸ›¡ï¸ å®‰å…¨æ¸¬è©¦

### æ•…éšœæ³¨å…¥æ¸¬è©¦
```cpp
// tests/safety_tests/test_fault_injection.cpp
class FaultInjectionTest : public TestFixture {
public:
    enum FaultType {
        FAULT_SENSOR_TIMEOUT,
        FAULT_INVALID_DATA,
        FAULT_COMMUNICATION_ERROR,
        FAULT_MEMORY_CORRUPTION
    };
    
    void injectFault(FaultType fault_type) {
        switch (fault_type) {
            case FAULT_SENSOR_TIMEOUT:
                // æ¨¡æ“¬æ„Ÿæ¸¬å™¨è¶…æ™‚
                mock_uart_->simulateTimeout();
                break;
                
            case FAULT_INVALID_DATA:
                // æ³¨å…¥ç„¡æ•ˆè³‡æ–™
                mock_uart_->injectCorruptedData();
                break;
                
            case FAULT_COMMUNICATION_ERROR:
                // æ¨¡æ“¬é€šè¨ŠéŒ¯èª¤
                mock_uart_->simulateError();
                break;
                
            default:
                break;
        }
    }
    
private:
    std::unique_ptr<MockUART> mock_uart_;
    std::unique_ptr<SafetyGuardian> safety_guardian_;
};

void test_sensor_timeout_recovery(void) {
    FaultInjectionTest test;
    test.setUp();
    
    // æ³¨å…¥æ„Ÿæ¸¬å™¨è¶…æ™‚æ•…éšœ
    test.injectFault(FaultInjectionTest::FAULT_SENSOR_TIMEOUT);
    
    // é©—è­‰å®‰å…¨å®ˆè­·æ˜¯å¦æ­£ç¢ºæª¢æ¸¬åˆ°æ•…éšœ
    SafetyLevel safety_level = test.safety_guardian_->checkSystemSafety();
    TEST_ASSERT_EQUAL(SAFETY_WARNING, safety_level);
    
    // é©—è­‰æ˜¯å¦è§¸ç™¼æ¢å¾©æ©Ÿåˆ¶
    bool recovery_attempted = test.safety_guardian_->attemptRecovery(FAULT_SENSOR_TIMEOUT);
    TEST_ASSERT_TRUE(recovery_attempted);
    
    test.tearDown();
}
```

## ğŸ“ˆ æ¸¬è©¦è‡ªå‹•åŒ–

### æŒçºŒæ•´åˆé…ç½®
```yaml
# .github/workflows/tests.yml
name: GMINS Tests

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Install PlatformIO
        run: pip install platformio
        
      - name: Run Unit Tests
        run: pio test -e native_test
        
      - name: Generate Coverage Report
        run: pio test -e native_test --coverage
        
      - name: Upload Coverage
        uses: codecov/codecov-action@v1
        with:
          file: ./coverage.xml

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - uses: actions/checkout@v2
      
      - name: Install PlatformIO
        run: pip install platformio
        
      - name: Run Integration Tests
        run: pio test -e integration_test

  hardware-tests:
    runs-on: self-hosted  # éœ€è¦å¯¦éš›ç¡¬é«”
    needs: integration-tests
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v2
      
      - name: Deploy to Test Hardware
        run: pio run -t upload
        
      - name: Run Hardware Tests
        run: ./scripts/run_hardware_tests.sh
```

## ğŸ”— ç›¸é—œæ–‡ä»¶é€£çµ

### é–‹ç™¼æ¨™æº–
- [[5.å¯¦ä½œæŒ‡å°/ç·¨ç¢¼è¦ç¯„]] - ä»£ç¢¼é¢¨æ ¼å’Œé–‹ç™¼æ¨™æº–
- [[5.å¯¦ä½œæŒ‡å°/é–‹ç™¼ç’°å¢ƒè¨­ç½®]] - é–‹ç™¼ç’°å¢ƒé…ç½®

### æ¶æ§‹æ–‡ä»¶
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/æ–°è»Ÿé«”æ¶æ§‹è¨­è¨ˆ]] - æ•´é«”è»Ÿé«”æ¶æ§‹
- [[4.æºä»£ç¢¼æ¶æ§‹/æ ¸å¿ƒæ¨¡çµ„è¨­è¨ˆ]] - å„æ ¸å¿ƒæ¨¡çµ„è©³ç´°è¨­è¨ˆ

### å…¶ä»–æ¸¬è©¦è³‡æº
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/æ¨¡çµ„åŒ–è¨­è¨ˆæ–¹é‡]] - æ¨¡çµ„åŒ–è¨­è¨ˆå’Œå¯æ¸¬è©¦æ€§

---

**æœ€å¾Œæ›´æ–°**: 2025-08-08  
**é©ç”¨ç‰ˆæœ¬**: GMINS v2.0  
**ç¶­è­·è€…**: GMINS é–‹ç™¼åœ˜éšŠ  
**æ¸¬è©¦è¦†è“‹ç‡ç›®æ¨™**: å–®å…ƒæ¸¬è©¦ > 90%, æ•´åˆæ¸¬è©¦ > 85%
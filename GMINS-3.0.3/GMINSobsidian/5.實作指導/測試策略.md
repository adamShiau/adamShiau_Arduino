# 測試策略

> **功能**: GMINS v2.0 全面測試策略和品質保證方案  
> **版本**: v2.0  
> **最後更新**: 2025-08-08  
> **測試框架**: Unity + 自定義測試工具

## 🎯 測試目標

### 品質保證目標
1. **功能正確性**: 確保所有功能按規格正常工作
2. **可靠性**: 系統能夠穩定運行 24/7
3. **性能達標**: 滿足即時性能要求
4. **安全性**: 確保系統在各種情況下的安全運行
5. **可維護性**: 便於後續開發和維護

### 測試覆蓋率目標
- **單元測試覆蓋率**: > 90%
- **整合測試覆蓋率**: > 85%
- **系統測試覆蓋率**: > 80%
- **安全測試覆蓋率**: 100% (關鍵安全功能)

## 🏗️ 測試架構

### 測試金字塔
```
                    ┌─────────────────┐
                    │   系統測試      │  (少量)
                    │ System Tests    │  複雜、慢速、高價值
                    └─────────────────┘
                   ┌───────────────────┐
                   │    整合測試       │  (中等)
                   │ Integration Tests │  中等複雜度、中等速度
                   └───────────────────┘
              ┌──────────────────────────┐
              │        單元測試          │  (大量)
              │     Unit Tests           │  簡單、快速、低成本
              └──────────────────────────┘
```

### 測試層級劃分

#### 1. 單元測試 (Unit Tests)
- **範圍**: 個別函數和類別方法
- **目標**: 驗證最小可測試單元的正確性
- **工具**: Unity Test Framework
- **執行頻率**: 每次程式碼變更

#### 2. 整合測試 (Integration Tests)
- **範圍**: 模組間介面和資料流
- **目標**: 驗證模組間的協作正確性
- **工具**: Unity + Mock Objects
- **執行頻率**: 每日自動執行

#### 3. 系統測試 (System Tests)
- **範圍**: 完整系統功能
- **目標**: 驗證系統整體功能和性能
- **工具**: 硬體在環測試 (HIL)
- **執行頻率**: 每週執行

#### 4. 驗收測試 (Acceptance Tests)
- **範圍**: 使用者需求和用例
- **目標**: 確保滿足使用者需求
- **工具**: 實際硬體測試
- **執行頻率**: 發布前執行

## 🧪 單元測試策略

### 測試框架設置
```cpp
// tests/test_config.h
#ifndef TEST_CONFIG_H_
#define TEST_CONFIG_H_

#include <unity.h>
#include <memory>

// 測試輔助巨集
#define TEST_ASSERT_FLOAT_WITHIN_RANGE(expected, actual, tolerance) \
    TEST_ASSERT_FLOAT_WITHIN(tolerance, expected, actual)

#define TEST_ASSERT_VECTOR3_EQUAL(expected, actual, tolerance) \
    do { \
        TEST_ASSERT_FLOAT_WITHIN(tolerance, expected.x, actual.x); \
        TEST_ASSERT_FLOAT_WITHIN(tolerance, expected.y, actual.y); \
        TEST_ASSERT_FLOAT_WITHIN(tolerance, expected.z, actual.z); \
    } while(0)

// 測試夾具基類
class TestFixture {
public:
    virtual void setUp() {}
    virtual void tearDown() {}
    
protected:
    // 通用測試工具
    bool compareFloats(float a, float b, float epsilon = 1e-6f) {
        return std::abs(a - b) < epsilon;
    }
    
    void printTestResult(const char* test_name, bool passed) {
        Serial.print(test_name);
        Serial.print(": ");
        Serial.println(passed ? "PASSED" : "FAILED");
    }
};

#endif  // TEST_CONFIG_H_
```

### 核心模組測試範例

#### FusionEngine 單元測試
```cpp
// tests/unit_tests/test_fusion_engine.cpp
#include "test_config.h"
#include "core/fusion_engine.h"
#include "mocks/mock_logger.h"

using namespace gmins::core;

class FusionEngineTest : public TestFixture {
public:
    void setUp() override {
        mock_logger_ = std::make_unique<MockLogger>();
        fusion_engine_ = std::make_unique<FusionEngine>(mock_logger_.get());
    }
    
    void tearDown() override {
        fusion_engine_.reset();
        mock_logger_.reset();
    }
    
protected:
    std::unique_ptr<MockLogger> mock_logger_;
    std::unique_ptr<FusionEngine> fusion_engine_;
    
    // 測試資料生成
    SensorDataPacket createTestSensorData() {
        SensorDataPacket data;
        data.timestamp_us = 1000000;  // 1 second
        
        // IMU 測試資料
        data.imu_data.orientation = Quaternion(1.0f, 0.0f, 0.0f, 0.0f);
        data.imu_data.angular_velocity = Vector3f(0.1f, 0.2f, 0.3f);
        data.imu_data.acceleration = Vector3f(0.0f, 0.0f, -9.81f);
        data.has_imu_data = true;
        
        // GPS 測試資料
        data.gps_data.latitude = 25.0330;   // 台北
        data.gps_data.longitude = 121.5654;
        data.gps_data.altitude = 100.0f;
        data.gps_data.velocity = Vector3f(1.0f, 0.0f, 0.0f);
        data.gps_data.satellites_used = 8;
        data.gps_data.hdop = 1.2f;
        data.has_gps_data = true;
        
        return data;
    }
};

// 測試用例
void test_fusion_engine_initialization(void) {
    FusionEngineTest test;
    test.setUp();
    
    FusionConfig config;
    bool result = test.fusion_engine_->initialize(config);
    
    TEST_ASSERT_TRUE(result);
    TEST_ASSERT_EQUAL(FusionEngine::STATE_READY, 
                      test.fusion_engine_->getState());
    
    test.tearDown();
}

void test_sensor_data_processing(void) {
    FusionEngineTest test;
    test.setUp();
    
    // 初始化融合引擎
    FusionConfig config;
    test.fusion_engine_->initialize(config);
    
    // 處理測試資料
    SensorDataPacket test_data = test.createTestSensorData();
    test.fusion_engine_->processSensorData(test_data);
    
    // 驗證結果
    NavigationState nav_state = test.fusion_engine_->getNavigationState();
    
    TEST_ASSERT_TRUE(nav_state.timestamp_us > 0);
    TEST_ASSERT_FLOAT_WITHIN(0.001, 25.0330, nav_state.position_llh.latitude);
    TEST_ASSERT_FLOAT_WITHIN(0.001, 121.5654, nav_state.position_llh.longitude);
    
    test.tearDown();
}

void test_dynamic_weights_update(void) {
    FusionEngineTest test;
    test.setUp();
    
    FusionConfig config;
    test.fusion_engine_->initialize(config);
    
    // 測試靜止狀態
    MotionState static_motion;
    static_motion.velocity_magnitude = 0.0f;
    static_motion.acceleration_magnitude = 0.0f;
    static_motion.angular_rate_magnitude = 0.0f;
    
    test.fusion_engine_->updateDynamicWeights(static_motion);
    DynamicWeights weights = test.fusion_engine_->getCurrentWeights();
    
    // 靜止時應該更信任 GNSS
    TEST_ASSERT_GREATER_THAN(0.5f, weights.gnss_position_weight);
    TEST_ASSERT_LESS_THAN(0.5f, weights.imu_position_weight);
    
    test.tearDown();
}

void test_coordinate_transformation(void) {
    FusionEngineTest test;
    test.setUp();
    
    // 測試 LLH 到 ENU 轉換
    LLHPosition origin{25.0330, 121.5654, 100.0};
    LLHPosition target{25.0340, 121.5664, 110.0};
    
    Vector3d enu_pos = test.fusion_engine_->llhToEnu(target, origin);
    
    // 驗證轉換結果合理性
    TEST_ASSERT_GREATER_THAN(0.0, enu_pos.x);  // 向東
    TEST_ASSERT_GREATER_THAN(0.0, enu_pos.y);  // 向北  
    TEST_ASSERT_FLOAT_WITHIN(1.0, 10.0, enu_pos.z);  // 向上 10m
    
    test.tearDown();
}

// 測試執行器
void runFusionEngineTests() {
    UNITY_BEGIN();
    
    RUN_TEST(test_fusion_engine_initialization);
    RUN_TEST(test_sensor_data_processing);
    RUN_TEST(test_dynamic_weights_update);
    RUN_TEST(test_coordinate_transformation);
    
    UNITY_END();
}
```

### Mock 物件實作
```cpp
// tests/mocks/mock_logger.h
#ifndef MOCK_LOGGER_H_
#define MOCK_LOGGER_H_

#include "utils/logger.h"
#include <vector>
#include <string>

class MockLogger : public Logger {
public:
    struct LogEntry {
        LogLevel level;
        std::string message;
        uint32_t timestamp;
    };
    
    void log(LogLevel level, const std::string& message) override {
        LogEntry entry;
        entry.level = level;
        entry.message = message;
        entry.timestamp = millis();
        log_entries_.push_back(entry);
    }
    
    // 測試輔助方法
    size_t getLogCount() const { return log_entries_.size(); }
    
    size_t getLogCount(LogLevel level) const {
        size_t count = 0;
        for (const auto& entry : log_entries_) {
            if (entry.level == level) {
                count++;
            }
        }
        return count;
    }
    
    bool hasLogMessage(const std::string& message) const {
        for (const auto& entry : log_entries_) {
            if (entry.message.find(message) != std::string::npos) {
                return true;
            }
        }
        return false;
    }
    
    void clearLogs() {
        log_entries_.clear();
    }
    
    const std::vector<LogEntry>& getLogs() const {
        return log_entries_;
    }
    
private:
    std::vector<LogEntry> log_entries_;
};

#endif  // MOCK_LOGGER_H_
```

## 🔗 整合測試策略

### 模組間通訊測試
```cpp
// tests/integration_tests/test_comm_fusion_integration.cpp
#include "test_config.h"
#include "communication/comm_manager.h"
#include "core/fusion_engine.h"
#include "mocks/mock_uart.h"

class CommFusionIntegrationTest : public TestFixture {
public:
    void setUp() override {
        mock_uart_ = std::make_unique<MockUART>();
        mock_logger_ = std::make_unique<MockLogger>();
        
        comm_manager_ = std::make_unique<CommunicationManager>(mock_logger_.get());
        fusion_engine_ = std::make_unique<FusionEngine>(mock_logger_.get());
        
        // 設置模擬 UART
        comm_manager_->setUARTInterface(CHANNEL_MTI680, mock_uart_.get());
    }
    
    void tearDown() override {
        fusion_engine_.reset();
        comm_manager_.reset();
        mock_logger_.reset();
        mock_uart_.reset();
    }
    
protected:
    std::unique_ptr<MockUART> mock_uart_;
    std::unique_ptr<MockLogger> mock_logger_;
    std::unique_ptr<CommunicationManager> comm_manager_;
    std::unique_ptr<FusionEngine> fusion_engine_;
};

void test_sensor_data_flow(void) {
    CommFusionIntegrationTest test;
    test.setUp();
    
    // 準備模擬 XBUS 資料
    uint8_t xbus_packet[] = {
        0xFA, 0xFF,  // XBUS preamble
        0x36, 0x00,  // Message ID and length
        // ... XBUS payload ...
        0x00, 0x00   // Checksum
    };
    
    // 設置模擬 UART 接收資料
    test.mock_uart_->setIncomingData(xbus_packet, sizeof(xbus_packet));
    
    // 初始化系統
    test.comm_manager_->initialize();
    test.fusion_engine_->initialize(FusionConfig{});
    
    // 處理資料
    test.comm_manager_->processIncomingData();
    
    // 驗證通訊管理器是否正確解析資料
    TEST_ASSERT_TRUE(test.comm_manager_->hasNewSensorData());
    
    SensorDataPacket sensor_data = test.comm_manager_->getLatestSensorData();
    TEST_ASSERT_TRUE(sensor_data.has_imu_data);
    
    // 將資料傳遞給融合引擎
    test.fusion_engine_->processSensorData(sensor_data);
    
    // 驗證融合引擎是否正確處理資料
    NavigationState nav_state = test.fusion_engine_->getNavigationState();
    TEST_ASSERT_TRUE(nav_state.timestamp_us > 0);
    
    test.tearDown();
}
```

## 🏭 系統測試策略

### 硬體在環 (HIL) 測試
```cpp
// tests/system_tests/test_complete_system.cpp
class CompleteSystemTest : public TestFixture {
public:
    void setUp() override {
        // 設置完整的硬體環境
        setupHardware();
        
        system_controller_ = std::make_unique<SystemController>(
            Logger::getInstance());
    }
    
    void tearDown() override {
        system_controller_->shutdown();
        system_controller_.reset();
        cleanupHardware();
    }
    
private:
    void setupHardware() {
        // 初始化真實的 UART 介面
        Serial1.begin(460800);  // Pixhawk
        Serial2.begin(115200);  // MTi-680
        Serial3.begin(115200);  // NMEA Out
        Serial4.begin(115200);  // NMEA In
        
        delay(1000);  // 等待硬體穩定
    }
    
    void cleanupHardware() {
        Serial1.end();
        Serial2.end();
        Serial3.end();
        Serial4.end();
    }
    
    std::unique_ptr<SystemController> system_controller_;
};

void test_complete_system_startup(void) {
    CompleteSystemTest test;
    test.setUp();
    
    // 測試系統啟動
    bool init_result = test.system_controller_->initialize();
    TEST_ASSERT_TRUE(init_result);
    TEST_ASSERT_EQUAL(SystemController::STATE_READY, 
                      test.system_controller_->getState());
    
    // 運行系統一段時間
    unsigned long start_time = millis();
    unsigned long test_duration = 5000;  // 5 seconds
    
    while (millis() - start_time < test_duration) {
        test.system_controller_->update();
        delay(10);
    }
    
    // 驗證系統狀態
    TEST_ASSERT_EQUAL(SystemController::STATE_RUNNING, 
                      test.system_controller_->getState());
    
    test.tearDown();
}

void test_sensor_data_processing_end_to_end(void) {
    CompleteSystemTest test;
    test.setUp();
    
    test.system_controller_->initialize();
    
    // 模擬感測器資料輸入並驗證 MAVLink 輸出
    unsigned long start_time = millis();
    bool mavlink_received = false;
    
    while (millis() - start_time < 10000 && !mavlink_received) {  // 10 seconds timeout
        test.system_controller_->update();
        
        // 檢查是否有 MAVLink 輸出
        if (Serial1.available()) {
            // 簡單檢查是否為有效的 MAVLink 封包
            uint8_t byte = Serial1.read();
            if (byte == MAVLINK_STX) {  // MAVLink start byte
                mavlink_received = true;
            }
        }
        
        delay(1);
    }
    
    TEST_ASSERT_TRUE(mavlink_received);
    
    test.tearDown();
}
```

## 📊 性能測試

### 即時性能測試
```cpp
// tests/performance_tests/test_performance.cpp
class PerformanceTest : public TestFixture {
public:
    struct PerformanceMetrics {
        uint32_t max_processing_time_us;
        uint32_t avg_processing_time_us;
        uint32_t min_processing_time_us;
        uint32_t sample_count;
    };
    
    void measurePerformance(std::function<void()> test_function, 
                           PerformanceMetrics& metrics,
                           uint32_t iterations = 1000) {
        uint32_t total_time = 0;
        metrics.max_processing_time_us = 0;
        metrics.min_processing_time_us = UINT32_MAX;
        metrics.sample_count = iterations;
        
        for (uint32_t i = 0; i < iterations; ++i) {
            uint32_t start_time = micros();
            test_function();
            uint32_t end_time = micros();
            
            uint32_t duration = end_time - start_time;
            total_time += duration;
            
            if (duration > metrics.max_processing_time_us) {
                metrics.max_processing_time_us = duration;
            }
            if (duration < metrics.min_processing_time_us) {
                metrics.min_processing_time_us = duration;
            }
            
            delay(1);  // 避免連續測量的干擾
        }
        
        metrics.avg_processing_time_us = total_time / iterations;
    }
};

void test_fusion_engine_performance(void) {
    PerformanceTest test;
    test.setUp();
    
    MockLogger mock_logger;
    FusionEngine fusion_engine(&mock_logger);
    fusion_engine.initialize(FusionConfig{});
    
    SensorDataPacket test_data = createRealisticSensorData();
    
    PerformanceTest::PerformanceMetrics metrics;
    test.measurePerformance([&]() {
        fusion_engine.processSensorData(test_data);
    }, metrics);
    
    // 性能要求驗證
    TEST_ASSERT_LESS_THAN(5000, metrics.max_processing_time_us);  // < 5ms
    TEST_ASSERT_LESS_THAN(2000, metrics.avg_processing_time_us);  // < 2ms
    
    Serial.println("=== Fusion Engine Performance ===");
    Serial.printf("Max: %u us\n", metrics.max_processing_time_us);
    Serial.printf("Avg: %u us\n", metrics.avg_processing_time_us);
    Serial.printf("Min: %u us\n", metrics.min_processing_time_us);
    
    test.tearDown();
}
```

## 🛡️ 安全測試

### 故障注入測試
```cpp
// tests/safety_tests/test_fault_injection.cpp
class FaultInjectionTest : public TestFixture {
public:
    enum FaultType {
        FAULT_SENSOR_TIMEOUT,
        FAULT_INVALID_DATA,
        FAULT_COMMUNICATION_ERROR,
        FAULT_MEMORY_CORRUPTION
    };
    
    void injectFault(FaultType fault_type) {
        switch (fault_type) {
            case FAULT_SENSOR_TIMEOUT:
                // 模擬感測器超時
                mock_uart_->simulateTimeout();
                break;
                
            case FAULT_INVALID_DATA:
                // 注入無效資料
                mock_uart_->injectCorruptedData();
                break;
                
            case FAULT_COMMUNICATION_ERROR:
                // 模擬通訊錯誤
                mock_uart_->simulateError();
                break;
                
            default:
                break;
        }
    }
    
private:
    std::unique_ptr<MockUART> mock_uart_;
    std::unique_ptr<SafetyGuardian> safety_guardian_;
};

void test_sensor_timeout_recovery(void) {
    FaultInjectionTest test;
    test.setUp();
    
    // 注入感測器超時故障
    test.injectFault(FaultInjectionTest::FAULT_SENSOR_TIMEOUT);
    
    // 驗證安全守護是否正確檢測到故障
    SafetyLevel safety_level = test.safety_guardian_->checkSystemSafety();
    TEST_ASSERT_EQUAL(SAFETY_WARNING, safety_level);
    
    // 驗證是否觸發恢復機制
    bool recovery_attempted = test.safety_guardian_->attemptRecovery(FAULT_SENSOR_TIMEOUT);
    TEST_ASSERT_TRUE(recovery_attempted);
    
    test.tearDown();
}
```

## 📈 測試自動化

### 持續整合配置
```yaml
# .github/workflows/tests.yml
name: GMINS Tests

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Install PlatformIO
        run: pip install platformio
        
      - name: Run Unit Tests
        run: pio test -e native_test
        
      - name: Generate Coverage Report
        run: pio test -e native_test --coverage
        
      - name: Upload Coverage
        uses: codecov/codecov-action@v1
        with:
          file: ./coverage.xml

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - uses: actions/checkout@v2
      
      - name: Install PlatformIO
        run: pip install platformio
        
      - name: Run Integration Tests
        run: pio test -e integration_test

  hardware-tests:
    runs-on: self-hosted  # 需要實際硬體
    needs: integration-tests
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v2
      
      - name: Deploy to Test Hardware
        run: pio run -t upload
        
      - name: Run Hardware Tests
        run: ./scripts/run_hardware_tests.sh
```

## 🔗 相關文件連結

### 開發標準
- [[5.實作指導/編碼規範]] - 代碼風格和開發標準
- [[5.實作指導/開發環境設置]] - 開發環境配置

### 架構文件
- [[3.軟體架構重新設計/新軟體架構設計]] - 整體軟體架構
- [[4.源代碼架構/核心模組設計]] - 各核心模組詳細設計

### 其他測試資源
- [[3.軟體架構重新設計/模組化設計方針]] - 模組化設計和可測試性

---

**最後更新**: 2025-08-08  
**適用版本**: GMINS v2.0  
**維護者**: GMINS 開發團隊  
**測試覆蓋率目標**: 單元測試 > 90%, 整合測試 > 85%
# 模組化設計方針

> **功能**: GMINS v2.0 模組化設計準則和實作指導  
> **版本**: v2.0  
> **最後更新**: 2025-08-08  
> **設計原則**: SOLID 原則, 低耦合高內聚

## 🎯 模組化設計原則

### SOLID 設計原則應用

#### 1. 單一職責原則 (Single Responsibility Principle)
每個模組只負責一個明確的功能，避免功能混雜。

```cpp
// ❌ 錯誤範例 - 職責混雜
class DataManager {
public:
    void parseNMEA();        // NMEA 解析
    void sendMAVLink();      // MAVLink 發送  
    void calculateFusion();  // 融合計算
    void logData();          // 資料記錄
};

// ✅ 正確範例 - 職責分離
class NMEAParser {
public:
    GPSData parseNMEASentence(const std::string& sentence);
};

class MAVLinkSender {
public:
    bool sendOdometry(const NavigationState& state);
};

class FusionCalculator {
public:
    NavigationState fuseSensorData(const SensorData& data);
};

class DataLogger {
public:
    void logNavigationState(const NavigationState& state);
};
```

#### 2. 開放封閉原則 (Open-Closed Principle)
模組對擴展開放，對修改封閉。

```cpp
// 抽象基類定義介面
class SensorDataHandler {
public:
    virtual ~SensorDataHandler() = default;
    virtual bool canHandle(const SensorData& data) = 0;
    virtual ProcessedData process(const SensorData& data) = 0;
};

// 具體實作 - 可擴展新的感測器處理器
class IMUDataHandler : public SensorDataHandler {
public:
    bool canHandle(const SensorData& data) override {
        return data.type == SENSOR_TYPE_IMU;
    }
    
    ProcessedData process(const SensorData& data) override {
        // IMU 特定處理邏輯
        return processIMUData(data.imu_data);
    }
};

class GPSDataHandler : public SensorDataHandler {
public:
    bool canHandle(const SensorData& data) override {
        return data.type == SENSOR_TYPE_GPS;
    }
    
    ProcessedData process(const SensorData& data) override {
        // GPS 特定處理邏輯
        return processGPSData(data.gps_data);
    }
};
```

#### 3. 里氏替換原則 (Liskov Substitution Principle)
派生類必須能夠替換基類，保證介面一致性。

```cpp
class CommunicationChannel {
public:
    virtual ~CommunicationChannel() = default;
    virtual bool initialize(const ChannelConfig& config) = 0;
    virtual int send(const uint8_t* data, size_t size) = 0;
    virtual int receive(uint8_t* buffer, size_t max_size) = 0;
    virtual bool isConnected() = 0;
};

// 任何通訊通道實作都可以替換基類使用
class UARTChannel : public CommunicationChannel {
    // 實作所有虛擬函數
};

class SPIChannel : public CommunicationChannel {
    // 實作所有虛擬函數
};

// 使用者代碼不需要知道具體實作類型
void sendData(CommunicationChannel& channel, const Data& data) {
    if (channel.isConnected()) {
        channel.send(data.buffer, data.size);
    }
}
```

#### 4. 介面隔離原則 (Interface Segregation Principle)
不應該強迫類別實作它們不需要的介面。

```cpp
// ❌ 錯誤 - 胖介面
class SensorInterface {
public:
    virtual GPSData getGPSData() = 0;        // 只有GPS需要
    virtual IMUData getIMUData() = 0;        // 只有IMU需要
    virtual float getPressure() = 0;         // 只有氣壓計需要
    virtual float getTemperature() = 0;      // 多種感測器需要
};

// ✅ 正確 - 介面分離
class GPSInterface {
public:
    virtual GPSData getGPSData() = 0;
};

class IMUInterface {
public:
    virtual IMUData getIMUData() = 0;
};

class PressureSensorInterface {
public:
    virtual float getPressure() = 0;
};

class TemperatureSensorInterface {
public:
    virtual float getTemperature() = 0;
};

// 感測器類別只實作需要的介面
class MTI680Sensor : public GPSInterface, public IMUInterface, public TemperatureSensorInterface {
    // 只實作相關的介面方法
};
```

#### 5. 依賴反轉原則 (Dependency Inversion Principle)
高層模組不應該依賴低層模組，兩者都應該依賴抽象。

```cpp
// 抽象依賴
class DataStorage {
public:
    virtual ~DataStorage() = default;
    virtual bool store(const std::string& key, const std::string& value) = 0;
    virtual std::string retrieve(const std::string& key) = 0;
};

class Logger {
public:
    virtual ~Logger() = default;
    virtual void log(LogLevel level, const std::string& message) = 0;
};

// 高層模組依賴抽象
class SystemController {
public:
    SystemController(std::unique_ptr<DataStorage> storage, 
                    std::unique_ptr<Logger> logger)
        : storage_(std::move(storage)), logger_(std::move(logger)) {}
    
    void saveConfiguration() {
        storage_->store("config", getCurrentConfig());
        logger_->log(LogLevel::INFO, "Configuration saved");
    }
    
private:
    std::unique_ptr<DataStorage> storage_;
    std::unique_ptr<Logger> logger_;
};
```

## 🏗️ 模組設計模式

### 1. 工廠模式 (Factory Pattern)
用於創建不同類型的物件，隱藏創建邏輯。

```cpp
class SensorFactory {
public:
    enum SensorType {
        SENSOR_MTI680,
        SENSOR_PIXHAWK_IMU,
        SENSOR_LOCOSYS_GPS
    };
    
    static std::unique_ptr<SensorInterface> createSensor(SensorType type) {
        switch (type) {
            case SENSOR_MTI680:
                return std::make_unique<MTI680Sensor>();
            case SENSOR_PIXHAWK_IMU:
                return std::make_unique<PixhawkIMUSensor>();
            case SENSOR_LOCOSYS_GPS:
                return std::make_unique<LocosysGPSSensor>();
            default:
                return nullptr;
        }
    }
};

// 使用方式
auto sensor = SensorFactory::createSensor(SensorFactory::SENSOR_MTI680);
if (sensor) {
    sensor->initialize();
}
```

### 2. 觀察者模式 (Observer Pattern)
用於模組間的事件通知機制。

```cpp
class EventObserver {
public:
    virtual ~EventObserver() = default;
    virtual void onEvent(const Event& event) = 0;
};

class EventPublisher {
public:
    void addObserver(EventObserver* observer) {
        observers_.push_back(observer);
    }
    
    void removeObserver(EventObserver* observer) {
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), observer),
            observers_.end());
    }
    
protected:
    void notifyObservers(const Event& event) {
        for (auto observer : observers_) {
            observer->onEvent(event);
        }
    }
    
private:
    std::vector<EventObserver*> observers_;
};

// 系統控制器發布系統事件
class SystemController : public EventPublisher {
public:
    void changeSystemState(SystemState new_state) {
        current_state_ = new_state;
        notifyObservers(SystemStateChangeEvent(new_state));
    }
};

// 安全守護監聽系統事件
class SafetyGuardian : public EventObserver {
public:
    void onEvent(const Event& event) override {
        if (event.type == EVENT_SYSTEM_STATE_CHANGE) {
            handleSystemStateChange(event);
        }
    }
};
```

### 3. 策略模式 (Strategy Pattern)
用於算法的動態選擇和切換。

```cpp
class FusionStrategy {
public:
    virtual ~FusionStrategy() = default;
    virtual NavigationState fuse(const IMUData& imu, const GPSData& gps) = 0;
};

class GNSSAHRSFusion : public FusionStrategy {
public:
    NavigationState fuse(const IMUData& imu, const GPSData& gps) override {
        // GNSS-AHRS 融合演算法
    }
};

class EKFBasedFusion : public FusionStrategy {
public:
    NavigationState fuse(const IMUData& imu, const GPSData& gps) override {
        // EKF 基礎融合演算法
    }
};

class FusionEngine {
public:
    void setFusionStrategy(std::unique_ptr<FusionStrategy> strategy) {
        fusion_strategy_ = std::move(strategy);
    }
    
    NavigationState processSensorData(const IMUData& imu, const GPSData& gps) {
        return fusion_strategy_->fuse(imu, gps);
    }
    
private:
    std::unique_ptr<FusionStrategy> fusion_strategy_;
};
```

## 🔌 模組間介面設計

### 1. 標準化訊息介面
定義統一的訊息格式用於模組間通訊。

```cpp
// 基礎訊息類型
enum MessageType {
    MSG_SENSOR_DATA,
    MSG_NAVIGATION_STATE,
    MSG_SYSTEM_STATUS,
    MSG_ERROR_REPORT,
    MSG_CONFIGURATION
};

class Message {
public:
    Message(MessageType type, uint64_t timestamp = getCurrentTimestamp())
        : type_(type), timestamp_(timestamp) {}
    
    virtual ~Message() = default;
    
    MessageType getType() const { return type_; }
    uint64_t getTimestamp() const { return timestamp_; }
    
private:
    MessageType type_;
    uint64_t timestamp_;
};

// 具體訊息類型
class SensorDataMessage : public Message {
public:
    SensorDataMessage(const SensorDataPacket& data)
        : Message(MSG_SENSOR_DATA), sensor_data_(data) {}
    
    const SensorDataPacket& getSensorData() const { return sensor_data_; }
    
private:
    SensorDataPacket sensor_data_;
};

class NavigationStateMessage : public Message {
public:
    NavigationStateMessage(const NavigationState& state)
        : Message(MSG_NAVIGATION_STATE), nav_state_(state) {}
    
    const NavigationState& getNavigationState() const { return nav_state_; }
    
private:
    NavigationState nav_state_;
};
```

### 2. 訊息佇列系統
實作模組間異步通訊機制。

```cpp
class MessageQueue {
public:
    bool enqueue(std::unique_ptr<Message> message) {
        if (queue_.size() >= max_size_) {
            return false;  // 佇列已滿
        }
        
        queue_.push(std::move(message));
        return true;
    }
    
    std::unique_ptr<Message> dequeue() {
        if (queue_.empty()) {
            return nullptr;
        }
        
        auto message = std::move(queue_.front());
        queue_.pop();
        return message;
    }
    
    bool isEmpty() const { return queue_.empty(); }
    bool isFull() const { return queue_.size() >= max_size_; }
    size_t size() const { return queue_.size(); }
    
private:
    std::queue<std::unique_ptr<Message>> queue_;
    static constexpr size_t max_size_ = 32;
};

// 訊息路由器
class MessageRouter {
public:
    using MessageHandler = std::function<void(const Message&)>;
    
    void registerHandler(MessageType type, MessageHandler handler) {
        handlers_[type] = handler;
    }
    
    void routeMessage(const Message& message) {
        auto it = handlers_.find(message.getType());
        if (it != handlers_.end()) {
            it->second(message);
        }
    }
    
private:
    std::map<MessageType, MessageHandler> handlers_;
};
```

## 📊 模組依賴管理

### 1. 依賴注入容器
實作簡單的依賴注入機制。

```cpp
class DIContainer {
public:
    template<typename T>
    void registerSingleton(std::function<std::unique_ptr<T>()> factory) {
        auto type_id = std::type_index(typeid(T));
        singletons_[type_id] = [factory]() -> std::unique_ptr<void> {
            return std::unique_ptr<void>(factory().release());
        };
    }
    
    template<typename T>
    T* resolve() {
        auto type_id = std::type_index(typeid(T));
        auto it = instances_.find(type_id);
        
        if (it != instances_.end()) {
            return static_cast<T*>(it->second.get());
        }
        
        auto factory_it = singletons_.find(type_id);
        if (factory_it != singletons_.end()) {
            auto instance = factory_it->second();
            T* ptr = static_cast<T*>(instance.get());
            instances_[type_id] = std::move(instance);
            return ptr;
        }
        
        return nullptr;
    }
    
private:
    std::map<std::type_index, std::function<std::unique_ptr<void>()>> singletons_;
    std::map<std::type_index, std::unique_ptr<void>> instances_;
};

// 使用範例
void setupDependencies(DIContainer& container) {
    container.registerSingleton<Logger>([]() {
        return std::make_unique<SerialLogger>();
    });
    
    container.registerSingleton<CommunicationManager>([]() {
        return std::make_unique<CommunicationManager>();
    });
    
    container.registerSingleton<FusionEngine>([&container]() {
        auto logger = container.resolve<Logger>();
        return std::make_unique<FusionEngine>(logger);
    });
}
```

### 2. 模組生命週期管理
統一管理所有模組的生命週期。

```cpp
class ModuleManager {
public:
    enum ModuleState {
        STATE_UNINITIALIZED,
        STATE_INITIALIZING,
        STATE_RUNNING,
        STATE_STOPPING,
        STATE_STOPPED,
        STATE_ERROR
    };
    
    class Module {
    public:
        virtual ~Module() = default;
        virtual bool initialize() = 0;
        virtual void start() = 0;
        virtual void stop() = 0;
        virtual void update() = 0;
        virtual ModuleState getState() const = 0;
        virtual std::string getName() const = 0;
    };
    
    void registerModule(std::unique_ptr<Module> module) {
        modules_.push_back(std::move(module));
    }
    
    bool initializeAll() {
        for (auto& module : modules_) {
            if (!module->initialize()) {
                Logger::log(LogLevel::ERROR, 
                           "Failed to initialize module: " + module->getName());
                return false;
            }
        }
        return true;
    }
    
    void startAll() {
        for (auto& module : modules_) {
            module->start();
        }
    }
    
    void updateAll() {
        for (auto& module : modules_) {
            if (module->getState() == STATE_RUNNING) {
                module->update();
            }
        }
    }
    
    void stopAll() {
        // 以相反順序停止模組
        for (auto it = modules_.rbegin(); it != modules_.rend(); ++it) {
            (*it)->stop();
        }
    }
    
private:
    std::vector<std::unique_ptr<Module>> modules_;
};
```

## 🧪 模組化測試策略

### 1. 模擬物件 (Mock Objects)
為單元測試創建模擬依賴。

```cpp
class MockCommunicationManager : public CommunicationManager {
public:
    MOCK_METHOD(bool, initialize, (), (override));
    MOCK_METHOD(void, processIncomingData, (), (override));
    MOCK_METHOD(bool, sendData, (ChannelId channel, const uint8_t* data, size_t size), (override));
    MOCK_METHOD(CommChannelStats, getChannelStats, (ChannelId channel), (override));
    MOCK_METHOD(bool, isChannelHealthy, (ChannelId channel), (override));
};

// 測試範例
TEST_F(FusionEngineTest, ProcessSensorDataTest) {
    MockCommunicationManager mock_comm;
    FusionEngine engine(&mock_comm);
    
    SensorDataPacket test_data;
    // 設置測試資料
    
    EXPECT_CALL(mock_comm, isChannelHealthy(CHANNEL_MTI680))
        .WillOnce(Return(true));
    
    engine.processSensorData(test_data);
    
    NavigationState result = engine.getNavigationState();
    // 驗證結果
}
```

### 2. 測試夾具 (Test Fixtures)
為測試提供標準化的設置和清理。

```cpp
class GMINSTestFixture : public ::testing::Test {
protected:
    void SetUp() override {
        // 創建測試用的依賴物件
        mock_logger_ = std::make_unique<MockLogger>();
        mock_storage_ = std::make_unique<MockDataStorage>();
        
        // 設置通用期望值
        EXPECT_CALL(*mock_logger_, log(_, _))
            .WillRepeatedly(Return());
        
        // 創建被測試物件
        system_controller_ = std::make_unique<SystemController>(
            std::move(mock_storage_), 
            mock_logger_.get());
    }
    
    void TearDown() override {
        system_controller_.reset();
        mock_logger_.reset();
        mock_storage_.reset();
    }
    
    std::unique_ptr<MockLogger> mock_logger_;
    std::unique_ptr<MockDataStorage> mock_storage_;
    std::unique_ptr<SystemController> system_controller_;
};
```

## 🔗 相關文件連結

### 設計文件
- [[3.軟體架構重新設計/新軟體架構設計]] - 整體軟體架構
- [[4.源代碼架構/核心模組設計]] - 各核心模組詳細設計
- [[src目錄結構設計]] - 源代碼組織結構

### 實作指導
- [[5.實作指導/編碼規範]] - 代碼風格和開發標準
- [[5.實作指導/測試策略]] - 測試方法和品質保證
- [[3.軟體架構重新設計/代碼組織規範]] - 代碼組織標準

### 其他參考
- [[1.系統概覽/GMINS專案架構總覽]] - 專案整體架構
- [[4.源代碼架構/通訊模組設計]] - 通訊模組設計細節

---

**最後更新**: 2025-08-08  
**適用版本**: GMINS v2.0  
**維護者**: GMINS 開發團隊  
**設計準則**: SOLID 原則, 設計模式最佳實踐
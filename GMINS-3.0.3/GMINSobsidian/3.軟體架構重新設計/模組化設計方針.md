# æ¨¡çµ„åŒ–è¨­è¨ˆæ–¹é‡

> **åŠŸèƒ½**: GMINS v2.0 æ¨¡çµ„åŒ–è¨­è¨ˆæº–å‰‡å’Œå¯¦ä½œæŒ‡å°  
> **ç‰ˆæœ¬**: v2.0  
> **æœ€å¾Œæ›´æ–°**: 2025-08-08  
> **è¨­è¨ˆåŸå‰‡**: SOLID åŸå‰‡, ä½è€¦åˆé«˜å…§èš

## ğŸ¯ æ¨¡çµ„åŒ–è¨­è¨ˆåŸå‰‡

### SOLID è¨­è¨ˆåŸå‰‡æ‡‰ç”¨

#### 1. å–®ä¸€è·è²¬åŸå‰‡ (Single Responsibility Principle)
æ¯å€‹æ¨¡çµ„åªè² è²¬ä¸€å€‹æ˜ç¢ºçš„åŠŸèƒ½ï¼Œé¿å…åŠŸèƒ½æ··é›œã€‚

```cpp
// âŒ éŒ¯èª¤ç¯„ä¾‹ - è·è²¬æ··é›œ
class DataManager {
public:
    void parseNMEA();        // NMEA è§£æ
    void sendMAVLink();      // MAVLink ç™¼é€  
    void calculateFusion();  // èåˆè¨ˆç®—
    void logData();          // è³‡æ–™è¨˜éŒ„
};

// âœ… æ­£ç¢ºç¯„ä¾‹ - è·è²¬åˆ†é›¢
class NMEAParser {
public:
    GPSData parseNMEASentence(const std::string& sentence);
};

class MAVLinkSender {
public:
    bool sendOdometry(const NavigationState& state);
};

class FusionCalculator {
public:
    NavigationState fuseSensorData(const SensorData& data);
};

class DataLogger {
public:
    void logNavigationState(const NavigationState& state);
};
```

#### 2. é–‹æ”¾å°é–‰åŸå‰‡ (Open-Closed Principle)
æ¨¡çµ„å°æ“´å±•é–‹æ”¾ï¼Œå°ä¿®æ”¹å°é–‰ã€‚

```cpp
// æŠ½è±¡åŸºé¡å®šç¾©ä»‹é¢
class SensorDataHandler {
public:
    virtual ~SensorDataHandler() = default;
    virtual bool canHandle(const SensorData& data) = 0;
    virtual ProcessedData process(const SensorData& data) = 0;
};

// å…·é«”å¯¦ä½œ - å¯æ“´å±•æ–°çš„æ„Ÿæ¸¬å™¨è™•ç†å™¨
class IMUDataHandler : public SensorDataHandler {
public:
    bool canHandle(const SensorData& data) override {
        return data.type == SENSOR_TYPE_IMU;
    }
    
    ProcessedData process(const SensorData& data) override {
        // IMU ç‰¹å®šè™•ç†é‚è¼¯
        return processIMUData(data.imu_data);
    }
};

class GPSDataHandler : public SensorDataHandler {
public:
    bool canHandle(const SensorData& data) override {
        return data.type == SENSOR_TYPE_GPS;
    }
    
    ProcessedData process(const SensorData& data) override {
        // GPS ç‰¹å®šè™•ç†é‚è¼¯
        return processGPSData(data.gps_data);
    }
};
```

#### 3. é‡Œæ°æ›¿æ›åŸå‰‡ (Liskov Substitution Principle)
æ´¾ç”Ÿé¡å¿…é ˆèƒ½å¤ æ›¿æ›åŸºé¡ï¼Œä¿è­‰ä»‹é¢ä¸€è‡´æ€§ã€‚

```cpp
class CommunicationChannel {
public:
    virtual ~CommunicationChannel() = default;
    virtual bool initialize(const ChannelConfig& config) = 0;
    virtual int send(const uint8_t* data, size_t size) = 0;
    virtual int receive(uint8_t* buffer, size_t max_size) = 0;
    virtual bool isConnected() = 0;
};

// ä»»ä½•é€šè¨Šé€šé“å¯¦ä½œéƒ½å¯ä»¥æ›¿æ›åŸºé¡ä½¿ç”¨
class UARTChannel : public CommunicationChannel {
    // å¯¦ä½œæ‰€æœ‰è™›æ“¬å‡½æ•¸
};

class SPIChannel : public CommunicationChannel {
    // å¯¦ä½œæ‰€æœ‰è™›æ“¬å‡½æ•¸
};

// ä½¿ç”¨è€…ä»£ç¢¼ä¸éœ€è¦çŸ¥é“å…·é«”å¯¦ä½œé¡å‹
void sendData(CommunicationChannel& channel, const Data& data) {
    if (channel.isConnected()) {
        channel.send(data.buffer, data.size);
    }
}
```

#### 4. ä»‹é¢éš”é›¢åŸå‰‡ (Interface Segregation Principle)
ä¸æ‡‰è©²å¼·è¿«é¡åˆ¥å¯¦ä½œå®ƒå€‘ä¸éœ€è¦çš„ä»‹é¢ã€‚

```cpp
// âŒ éŒ¯èª¤ - èƒ–ä»‹é¢
class SensorInterface {
public:
    virtual GPSData getGPSData() = 0;        // åªæœ‰GPSéœ€è¦
    virtual IMUData getIMUData() = 0;        // åªæœ‰IMUéœ€è¦
    virtual float getPressure() = 0;         // åªæœ‰æ°£å£“è¨ˆéœ€è¦
    virtual float getTemperature() = 0;      // å¤šç¨®æ„Ÿæ¸¬å™¨éœ€è¦
};

// âœ… æ­£ç¢º - ä»‹é¢åˆ†é›¢
class GPSInterface {
public:
    virtual GPSData getGPSData() = 0;
};

class IMUInterface {
public:
    virtual IMUData getIMUData() = 0;
};

class PressureSensorInterface {
public:
    virtual float getPressure() = 0;
};

class TemperatureSensorInterface {
public:
    virtual float getTemperature() = 0;
};

// æ„Ÿæ¸¬å™¨é¡åˆ¥åªå¯¦ä½œéœ€è¦çš„ä»‹é¢
class MTI680Sensor : public GPSInterface, public IMUInterface, public TemperatureSensorInterface {
    // åªå¯¦ä½œç›¸é—œçš„ä»‹é¢æ–¹æ³•
};
```

#### 5. ä¾è³´åè½‰åŸå‰‡ (Dependency Inversion Principle)
é«˜å±¤æ¨¡çµ„ä¸æ‡‰è©²ä¾è³´ä½å±¤æ¨¡çµ„ï¼Œå…©è€…éƒ½æ‡‰è©²ä¾è³´æŠ½è±¡ã€‚

```cpp
// æŠ½è±¡ä¾è³´
class DataStorage {
public:
    virtual ~DataStorage() = default;
    virtual bool store(const std::string& key, const std::string& value) = 0;
    virtual std::string retrieve(const std::string& key) = 0;
};

class Logger {
public:
    virtual ~Logger() = default;
    virtual void log(LogLevel level, const std::string& message) = 0;
};

// é«˜å±¤æ¨¡çµ„ä¾è³´æŠ½è±¡
class SystemController {
public:
    SystemController(std::unique_ptr<DataStorage> storage, 
                    std::unique_ptr<Logger> logger)
        : storage_(std::move(storage)), logger_(std::move(logger)) {}
    
    void saveConfiguration() {
        storage_->store("config", getCurrentConfig());
        logger_->log(LogLevel::INFO, "Configuration saved");
    }
    
private:
    std::unique_ptr<DataStorage> storage_;
    std::unique_ptr<Logger> logger_;
};
```

## ğŸ—ï¸ æ¨¡çµ„è¨­è¨ˆæ¨¡å¼

### 1. å·¥å» æ¨¡å¼ (Factory Pattern)
ç”¨æ–¼å‰µå»ºä¸åŒé¡å‹çš„ç‰©ä»¶ï¼Œéš±è—å‰µå»ºé‚è¼¯ã€‚

```cpp
class SensorFactory {
public:
    enum SensorType {
        SENSOR_MTI680,
        SENSOR_PIXHAWK_IMU,
        SENSOR_LOCOSYS_GPS
    };
    
    static std::unique_ptr<SensorInterface> createSensor(SensorType type) {
        switch (type) {
            case SENSOR_MTI680:
                return std::make_unique<MTI680Sensor>();
            case SENSOR_PIXHAWK_IMU:
                return std::make_unique<PixhawkIMUSensor>();
            case SENSOR_LOCOSYS_GPS:
                return std::make_unique<LocosysGPSSensor>();
            default:
                return nullptr;
        }
    }
};

// ä½¿ç”¨æ–¹å¼
auto sensor = SensorFactory::createSensor(SensorFactory::SENSOR_MTI680);
if (sensor) {
    sensor->initialize();
}
```

### 2. è§€å¯Ÿè€…æ¨¡å¼ (Observer Pattern)
ç”¨æ–¼æ¨¡çµ„é–“çš„äº‹ä»¶é€šçŸ¥æ©Ÿåˆ¶ã€‚

```cpp
class EventObserver {
public:
    virtual ~EventObserver() = default;
    virtual void onEvent(const Event& event) = 0;
};

class EventPublisher {
public:
    void addObserver(EventObserver* observer) {
        observers_.push_back(observer);
    }
    
    void removeObserver(EventObserver* observer) {
        observers_.erase(
            std::remove(observers_.begin(), observers_.end(), observer),
            observers_.end());
    }
    
protected:
    void notifyObservers(const Event& event) {
        for (auto observer : observers_) {
            observer->onEvent(event);
        }
    }
    
private:
    std::vector<EventObserver*> observers_;
};

// ç³»çµ±æ§åˆ¶å™¨ç™¼å¸ƒç³»çµ±äº‹ä»¶
class SystemController : public EventPublisher {
public:
    void changeSystemState(SystemState new_state) {
        current_state_ = new_state;
        notifyObservers(SystemStateChangeEvent(new_state));
    }
};

// å®‰å…¨å®ˆè­·ç›£è½ç³»çµ±äº‹ä»¶
class SafetyGuardian : public EventObserver {
public:
    void onEvent(const Event& event) override {
        if (event.type == EVENT_SYSTEM_STATE_CHANGE) {
            handleSystemStateChange(event);
        }
    }
};
```

### 3. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)
ç”¨æ–¼ç®—æ³•çš„å‹•æ…‹é¸æ“‡å’Œåˆ‡æ›ã€‚

```cpp
class FusionStrategy {
public:
    virtual ~FusionStrategy() = default;
    virtual NavigationState fuse(const IMUData& imu, const GPSData& gps) = 0;
};

class GNSSAHRSFusion : public FusionStrategy {
public:
    NavigationState fuse(const IMUData& imu, const GPSData& gps) override {
        // GNSS-AHRS èåˆæ¼”ç®—æ³•
    }
};

class EKFBasedFusion : public FusionStrategy {
public:
    NavigationState fuse(const IMUData& imu, const GPSData& gps) override {
        // EKF åŸºç¤èåˆæ¼”ç®—æ³•
    }
};

class FusionEngine {
public:
    void setFusionStrategy(std::unique_ptr<FusionStrategy> strategy) {
        fusion_strategy_ = std::move(strategy);
    }
    
    NavigationState processSensorData(const IMUData& imu, const GPSData& gps) {
        return fusion_strategy_->fuse(imu, gps);
    }
    
private:
    std::unique_ptr<FusionStrategy> fusion_strategy_;
};
```

## ğŸ”Œ æ¨¡çµ„é–“ä»‹é¢è¨­è¨ˆ

### 1. æ¨™æº–åŒ–è¨Šæ¯ä»‹é¢
å®šç¾©çµ±ä¸€çš„è¨Šæ¯æ ¼å¼ç”¨æ–¼æ¨¡çµ„é–“é€šè¨Šã€‚

```cpp
// åŸºç¤è¨Šæ¯é¡å‹
enum MessageType {
    MSG_SENSOR_DATA,
    MSG_NAVIGATION_STATE,
    MSG_SYSTEM_STATUS,
    MSG_ERROR_REPORT,
    MSG_CONFIGURATION
};

class Message {
public:
    Message(MessageType type, uint64_t timestamp = getCurrentTimestamp())
        : type_(type), timestamp_(timestamp) {}
    
    virtual ~Message() = default;
    
    MessageType getType() const { return type_; }
    uint64_t getTimestamp() const { return timestamp_; }
    
private:
    MessageType type_;
    uint64_t timestamp_;
};

// å…·é«”è¨Šæ¯é¡å‹
class SensorDataMessage : public Message {
public:
    SensorDataMessage(const SensorDataPacket& data)
        : Message(MSG_SENSOR_DATA), sensor_data_(data) {}
    
    const SensorDataPacket& getSensorData() const { return sensor_data_; }
    
private:
    SensorDataPacket sensor_data_;
};

class NavigationStateMessage : public Message {
public:
    NavigationStateMessage(const NavigationState& state)
        : Message(MSG_NAVIGATION_STATE), nav_state_(state) {}
    
    const NavigationState& getNavigationState() const { return nav_state_; }
    
private:
    NavigationState nav_state_;
};
```

### 2. è¨Šæ¯ä½‡åˆ—ç³»çµ±
å¯¦ä½œæ¨¡çµ„é–“ç•°æ­¥é€šè¨Šæ©Ÿåˆ¶ã€‚

```cpp
class MessageQueue {
public:
    bool enqueue(std::unique_ptr<Message> message) {
        if (queue_.size() >= max_size_) {
            return false;  // ä½‡åˆ—å·²æ»¿
        }
        
        queue_.push(std::move(message));
        return true;
    }
    
    std::unique_ptr<Message> dequeue() {
        if (queue_.empty()) {
            return nullptr;
        }
        
        auto message = std::move(queue_.front());
        queue_.pop();
        return message;
    }
    
    bool isEmpty() const { return queue_.empty(); }
    bool isFull() const { return queue_.size() >= max_size_; }
    size_t size() const { return queue_.size(); }
    
private:
    std::queue<std::unique_ptr<Message>> queue_;
    static constexpr size_t max_size_ = 32;
};

// è¨Šæ¯è·¯ç”±å™¨
class MessageRouter {
public:
    using MessageHandler = std::function<void(const Message&)>;
    
    void registerHandler(MessageType type, MessageHandler handler) {
        handlers_[type] = handler;
    }
    
    void routeMessage(const Message& message) {
        auto it = handlers_.find(message.getType());
        if (it != handlers_.end()) {
            it->second(message);
        }
    }
    
private:
    std::map<MessageType, MessageHandler> handlers_;
};
```

## ğŸ“Š æ¨¡çµ„ä¾è³´ç®¡ç†

### 1. ä¾è³´æ³¨å…¥å®¹å™¨
å¯¦ä½œç°¡å–®çš„ä¾è³´æ³¨å…¥æ©Ÿåˆ¶ã€‚

```cpp
class DIContainer {
public:
    template<typename T>
    void registerSingleton(std::function<std::unique_ptr<T>()> factory) {
        auto type_id = std::type_index(typeid(T));
        singletons_[type_id] = [factory]() -> std::unique_ptr<void> {
            return std::unique_ptr<void>(factory().release());
        };
    }
    
    template<typename T>
    T* resolve() {
        auto type_id = std::type_index(typeid(T));
        auto it = instances_.find(type_id);
        
        if (it != instances_.end()) {
            return static_cast<T*>(it->second.get());
        }
        
        auto factory_it = singletons_.find(type_id);
        if (factory_it != singletons_.end()) {
            auto instance = factory_it->second();
            T* ptr = static_cast<T*>(instance.get());
            instances_[type_id] = std::move(instance);
            return ptr;
        }
        
        return nullptr;
    }
    
private:
    std::map<std::type_index, std::function<std::unique_ptr<void>()>> singletons_;
    std::map<std::type_index, std::unique_ptr<void>> instances_;
};

// ä½¿ç”¨ç¯„ä¾‹
void setupDependencies(DIContainer& container) {
    container.registerSingleton<Logger>([]() {
        return std::make_unique<SerialLogger>();
    });
    
    container.registerSingleton<CommunicationManager>([]() {
        return std::make_unique<CommunicationManager>();
    });
    
    container.registerSingleton<FusionEngine>([&container]() {
        auto logger = container.resolve<Logger>();
        return std::make_unique<FusionEngine>(logger);
    });
}
```

### 2. æ¨¡çµ„ç”Ÿå‘½é€±æœŸç®¡ç†
çµ±ä¸€ç®¡ç†æ‰€æœ‰æ¨¡çµ„çš„ç”Ÿå‘½é€±æœŸã€‚

```cpp
class ModuleManager {
public:
    enum ModuleState {
        STATE_UNINITIALIZED,
        STATE_INITIALIZING,
        STATE_RUNNING,
        STATE_STOPPING,
        STATE_STOPPED,
        STATE_ERROR
    };
    
    class Module {
    public:
        virtual ~Module() = default;
        virtual bool initialize() = 0;
        virtual void start() = 0;
        virtual void stop() = 0;
        virtual void update() = 0;
        virtual ModuleState getState() const = 0;
        virtual std::string getName() const = 0;
    };
    
    void registerModule(std::unique_ptr<Module> module) {
        modules_.push_back(std::move(module));
    }
    
    bool initializeAll() {
        for (auto& module : modules_) {
            if (!module->initialize()) {
                Logger::log(LogLevel::ERROR, 
                           "Failed to initialize module: " + module->getName());
                return false;
            }
        }
        return true;
    }
    
    void startAll() {
        for (auto& module : modules_) {
            module->start();
        }
    }
    
    void updateAll() {
        for (auto& module : modules_) {
            if (module->getState() == STATE_RUNNING) {
                module->update();
            }
        }
    }
    
    void stopAll() {
        // ä»¥ç›¸åé †åºåœæ­¢æ¨¡çµ„
        for (auto it = modules_.rbegin(); it != modules_.rend(); ++it) {
            (*it)->stop();
        }
    }
    
private:
    std::vector<std::unique_ptr<Module>> modules_;
};
```

## ğŸ§ª æ¨¡çµ„åŒ–æ¸¬è©¦ç­–ç•¥

### 1. æ¨¡æ“¬ç‰©ä»¶ (Mock Objects)
ç‚ºå–®å…ƒæ¸¬è©¦å‰µå»ºæ¨¡æ“¬ä¾è³´ã€‚

```cpp
class MockCommunicationManager : public CommunicationManager {
public:
    MOCK_METHOD(bool, initialize, (), (override));
    MOCK_METHOD(void, processIncomingData, (), (override));
    MOCK_METHOD(bool, sendData, (ChannelId channel, const uint8_t* data, size_t size), (override));
    MOCK_METHOD(CommChannelStats, getChannelStats, (ChannelId channel), (override));
    MOCK_METHOD(bool, isChannelHealthy, (ChannelId channel), (override));
};

// æ¸¬è©¦ç¯„ä¾‹
TEST_F(FusionEngineTest, ProcessSensorDataTest) {
    MockCommunicationManager mock_comm;
    FusionEngine engine(&mock_comm);
    
    SensorDataPacket test_data;
    // è¨­ç½®æ¸¬è©¦è³‡æ–™
    
    EXPECT_CALL(mock_comm, isChannelHealthy(CHANNEL_MTI680))
        .WillOnce(Return(true));
    
    engine.processSensorData(test_data);
    
    NavigationState result = engine.getNavigationState();
    // é©—è­‰çµæœ
}
```

### 2. æ¸¬è©¦å¤¾å…· (Test Fixtures)
ç‚ºæ¸¬è©¦æä¾›æ¨™æº–åŒ–çš„è¨­ç½®å’Œæ¸…ç†ã€‚

```cpp
class GMINSTestFixture : public ::testing::Test {
protected:
    void SetUp() override {
        // å‰µå»ºæ¸¬è©¦ç”¨çš„ä¾è³´ç‰©ä»¶
        mock_logger_ = std::make_unique<MockLogger>();
        mock_storage_ = std::make_unique<MockDataStorage>();
        
        // è¨­ç½®é€šç”¨æœŸæœ›å€¼
        EXPECT_CALL(*mock_logger_, log(_, _))
            .WillRepeatedly(Return());
        
        // å‰µå»ºè¢«æ¸¬è©¦ç‰©ä»¶
        system_controller_ = std::make_unique<SystemController>(
            std::move(mock_storage_), 
            mock_logger_.get());
    }
    
    void TearDown() override {
        system_controller_.reset();
        mock_logger_.reset();
        mock_storage_.reset();
    }
    
    std::unique_ptr<MockLogger> mock_logger_;
    std::unique_ptr<MockDataStorage> mock_storage_;
    std::unique_ptr<SystemController> system_controller_;
};
```

## ğŸ”— ç›¸é—œæ–‡ä»¶é€£çµ

### è¨­è¨ˆæ–‡ä»¶
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/æ–°è»Ÿé«”æ¶æ§‹è¨­è¨ˆ]] - æ•´é«”è»Ÿé«”æ¶æ§‹
- [[4.æºä»£ç¢¼æ¶æ§‹/æ ¸å¿ƒæ¨¡çµ„è¨­è¨ˆ]] - å„æ ¸å¿ƒæ¨¡çµ„è©³ç´°è¨­è¨ˆ
- [[srcç›®éŒ„çµæ§‹è¨­è¨ˆ]] - æºä»£ç¢¼çµ„ç¹”çµæ§‹

### å¯¦ä½œæŒ‡å°
- [[5.å¯¦ä½œæŒ‡å°/ç·¨ç¢¼è¦ç¯„]] - ä»£ç¢¼é¢¨æ ¼å’Œé–‹ç™¼æ¨™æº–
- [[5.å¯¦ä½œæŒ‡å°/æ¸¬è©¦ç­–ç•¥]] - æ¸¬è©¦æ–¹æ³•å’Œå“è³ªä¿è­‰
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/ä»£ç¢¼çµ„ç¹”è¦ç¯„]] - ä»£ç¢¼çµ„ç¹”æ¨™æº–

### å…¶ä»–åƒè€ƒ
- [[1.ç³»çµ±æ¦‚è¦½/GMINSå°ˆæ¡ˆæ¶æ§‹ç¸½è¦½]] - å°ˆæ¡ˆæ•´é«”æ¶æ§‹
- [[4.æºä»£ç¢¼æ¶æ§‹/é€šè¨Šæ¨¡çµ„è¨­è¨ˆ]] - é€šè¨Šæ¨¡çµ„è¨­è¨ˆç´°ç¯€

---

**æœ€å¾Œæ›´æ–°**: 2025-08-08  
**é©ç”¨ç‰ˆæœ¬**: GMINS v2.0  
**ç¶­è­·è€…**: GMINS é–‹ç™¼åœ˜éšŠ  
**è¨­è¨ˆæº–å‰‡**: SOLID åŸå‰‡, è¨­è¨ˆæ¨¡å¼æœ€ä½³å¯¦è¸
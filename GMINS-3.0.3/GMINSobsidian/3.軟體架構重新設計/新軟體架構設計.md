# æ–°è»Ÿé«”æ¶æ§‹è¨­è¨ˆ

> **åŠŸèƒ½**: GMINS v2.0 è»Ÿé«”æ¶æ§‹å®Œæ•´é‡æ–°è¨­è¨ˆèªªæ˜  
> **ç‰ˆæœ¬**: v2.0  
> **æœ€å¾Œæ›´æ–°**: 2025-08-08  
> **è¨­è¨ˆç†å¿µ**: æ¨¡çµ„åŒ–ã€å¯ç¶­è­·ã€é«˜æ•ˆèƒ½

## ğŸ¯ è¨­è¨ˆç›®æ¨™èˆ‡æ”¹é€²

### å¾ MINSPixhawk åˆ° GMINS çš„é€²åŒ–
GMINS v2.0 åŸºæ–¼ MINSPixhawk çš„å¯¦æˆ°ç¶“é©—ï¼Œé€²è¡Œå®Œå…¨çš„è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆï¼Œè§£æ±ºåŸæœ‰æ¶æ§‹çš„å•é¡Œä¸¦æå‡æ•´é«”æ€§èƒ½ã€‚

#### åŸæœ‰æ¶æ§‹å•é¡Œåˆ†æ
1. **ä»£ç¢¼çµ„ç¹”æ··äº‚**: åŠŸèƒ½æ¨¡çµ„æ··é›œï¼Œé›£ä»¥ç¶­è­·
2. **è€¦åˆåº¦éé«˜**: æ¨¡çµ„é–“ä¾è³´è¤‡é›œï¼Œä¿®æ”¹å½±éŸ¿ç¯„åœå¤§  
3. **éŒ¯èª¤è™•ç†ä¸å®Œå–„**: ç¼ºä¹ç³»çµ±æ€§çš„éŒ¯èª¤æ¢å¾©æ©Ÿåˆ¶
4. **è³‡æºä½¿ç”¨æ•ˆç‡ä½**: è¨˜æ†¶é«”å’ŒCPUä½¿ç”¨æœªå„ªåŒ–
5. **æ¸¬è©¦å›°é›£**: ç¼ºä¹ç¨ç«‹å¯æ¸¬è©¦çš„æ¨¡çµ„è¨­è¨ˆ

#### GMINS v2.0 æ”¹é€²ç›®æ¨™
1. **æ¨¡çµ„åŒ–è¨­è¨ˆ**: æ¸…æ™°çš„åŠŸèƒ½åˆ†é›¢å’Œæ¨™æº–ä»‹é¢
2. **ä½è€¦åˆé«˜å…§èš**: æ¨¡çµ„é–“ä¾è³´æœ€å°åŒ–  
3. **å®Œå–„çš„éŒ¯èª¤è™•ç†**: å¤šå±¤æ¬¡éŒ¯èª¤æª¢æ¸¬å’Œè‡ªå‹•æ¢å¾©
4. **è³‡æºå„ªåŒ–**: é«˜æ•ˆçš„è¨˜æ†¶é«”å’ŒCPUè³‡æºä½¿ç”¨
5. **å¯æ¸¬è©¦æ€§**: æ¯å€‹æ¨¡çµ„éƒ½å¯ç¨ç«‹æ¸¬è©¦å’Œé©—è­‰
6. **æ–¹ä¾¿é™¤éŒ¯é–‹é—œ**

- æ¯å€‹æ¨¡çµ„éƒ½å¯ä»¥æœ‰è‡ªå·±çš„ `#define GNSS_DEBUG`ã€`#define IMU_DEBUG` æˆ–ä½¿ç”¨å…¨åŸŸ log ç³»çµ±çš„**åˆ†é¡é–‹é—œ**ã€‚
    
- ä½ å¯ä»¥å–®ç¨æ‰“é–‹æŸå€‹æ¨¡çµ„çš„ logï¼Œè€Œä¸æœƒè¢«å…¶ä»–æ¨¡çµ„æ´—ç‰ˆã€‚

## ğŸ—ï¸ æ•´é«”æ¶æ§‹è¨­è¨ˆ

### ç³»çµ±å±¤æ¬¡æ¶æ§‹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                        â”‚
â”‚                   (Arduino Main Loop)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Core Services                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   System    â”‚ â”‚   Fusion    â”‚ â”‚   Safety    â”‚          â”‚
â”‚  â”‚ Controller  â”‚ â”‚   Engine    â”‚ â”‚  Guardian   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Communication Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    Comm     â”‚ â”‚   MAVLink   â”‚ â”‚    XBUS     â”‚          â”‚
â”‚  â”‚   Manager   â”‚ â”‚   Handler   â”‚ â”‚   Handler   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚                         â”‚    NMEA     â”‚                    â”‚
â”‚                         â”‚   Handler   â”‚                    â”‚
â”‚                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    Data Processing Layer                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    Data     â”‚ â”‚ Coordinate  â”‚ â”‚   Sensor    â”‚          â”‚
â”‚  â”‚  Processor  â”‚ â”‚ Transform   â”‚ â”‚   Fusion    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Utility Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚Loggerâ”‚ â”‚Configâ”‚ â”‚Math  â”‚ â”‚Time  â”‚ â”‚Memoryâ”‚            â”‚
â”‚  â”‚      â”‚ â”‚ Mgr  â”‚ â”‚Utils â”‚ â”‚Utils â”‚ â”‚ Mgr  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                Hardware Abstraction Layer                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    UART     â”‚ â”‚   Pin Def   â”‚ â”‚   Board     â”‚          â”‚
â”‚  â”‚ Interface   â”‚ â”‚             â”‚ â”‚  Support    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒæ¶æ§‹çµ„ä»¶

### 1. SystemController - ç³»çµ±æ§åˆ¶å™¨
**è·è²¬**: ç³»çµ±ç”Ÿå‘½é€±æœŸç®¡ç†å’Œå”èª¿å„æ¨¡çµ„é‹ä½œ

```cpp
class SystemController {
public:
    // ç”Ÿå‘½é€±æœŸç®¡ç†
    enum SystemState {
        STATE_INITIALIZING,
        STATE_READY,
        STATE_RUNNING,
        STATE_ERROR,
        STATE_SHUTDOWN
    };
    
    // é‹ä½œæ¨¡å¼
    enum OperationMode {
        MODE_STARTUP,       // å•Ÿå‹•æ¨¡å¼
        MODE_NORMAL,        // æ­£å¸¸é‹ä½œ
        MODE_DEBUG,         // èª¿è©¦æ¨¡å¼  
        MODE_SAFE,          // å®‰å…¨æ¨¡å¼
        MODE_MAINTENANCE    // ç¶­è­·æ¨¡å¼
    };
    
    // æ ¸å¿ƒä»‹é¢
    bool initialize();
    void run();                    // ä¸»è¦åŸ·è¡Œå¾ªç’°
    void shutdown();
    bool setMode(OperationMode mode);
    SystemState getState() const;
    SystemHealth getHealthStatus();
    
private:
    void initializeSubsystems();
    void coordinateModules();
    void handleStateTransitions();
    void performHealthCheck();
    
    SystemState current_state_;
    OperationMode current_mode_;
    std::unique_ptr<CommunicationManager> comm_manager_;
    std::unique_ptr<FusionEngine> fusion_engine_;
    std::unique_ptr<SafetyGuardian> safety_guardian_;
    std::unique_ptr<DataProcessor> data_processor_;
};
```

### 2. CommunicationManager - é€šè¨Šç®¡ç†å™¨
**è·è²¬**: çµ±ä¸€ç®¡ç†æ‰€æœ‰ç¡¬é«”é€šè¨Šä»‹é¢

```cpp
class CommunicationManager {
public:
    enum ChannelId {
        CHANNEL_PIXHAWK = 0,    // Serial1 - MAVLink
        CHANNEL_MTI680 = 1,     // Serial2 - XBUS
        CHANNEL_NMEA_OUT = 2,   // Serial3 - NMEA Output
        CHANNEL_NMEA_IN = 3,    // Serial4 - NMEA Input
        CHANNEL_COUNT = 4
    };
    
    bool initialize();
    void processIncomingData();
    bool sendData(ChannelId channel, const uint8_t* data, size_t size);
    
    // ç‹€æ…‹ç›£æ§
    CommChannelStats getChannelStats(ChannelId channel);
    bool isChannelHealthy(ChannelId channel);
    void resetChannel(ChannelId channel);
    
    // éŒ¯èª¤è™•ç†
    void handleCommunicationError(ChannelId channel, CommError error);
    bool recoverFromError(ChannelId channel);
    
private:
    struct CommChannel {
        std::unique_ptr<UARTInterface> uart;
        uint32_t baud_rate;
        bool is_active;
        CommChannelStats stats;
        std::queue<uint8_t> rx_buffer;
        std::queue<uint8_t> tx_buffer;
    };
    
    std::array<CommChannel, CHANNEL_COUNT> channels_;
    std::unique_ptr<MAVLinkHandler> mavlink_handler_;
    std::unique_ptr<XBUSHandler> xbus_handler_;
    std::unique_ptr<NMEAHandler> nmea_handler_;
    
    void processChannelData(ChannelId channel);
    void updateChannelStats(ChannelId channel);
    bool validateChannelHealth(ChannelId channel);
};
```

### 3. FusionEngine - èåˆå¼•æ“  
**è·è²¬**: å¤šæ„Ÿæ¸¬å™¨è³‡æ–™èåˆå’Œç‹€æ…‹ä¼°è¨ˆ

```cpp
class FusionEngine {
public:
    struct FusionConfig {
        // å‹•æ…‹æ¬Šé‡é…ç½®
        float base_trust_factor = 0.1f;
        float max_trust_factor = 1.0f;
        float trust_decay_rate = 0.95f;
        
        // èåˆåƒæ•¸
        float position_weight_gnss = 0.7f;
        float position_weight_imu = 0.3f;
        float orientation_weight_gnss = 0.3f;
        float orientation_weight_imu = 0.7f;
        
        // æ™‚é–“åŒæ­¥
        uint32_t max_time_diff_us = 50000;  // 50ms
        bool enable_time_sync = true;
    };
    
    bool initialize(const FusionConfig& config);
    void processSensorData(const SensorDataPacket& data);
    NavigationState getNavigationState();
    FusionHealth getFusionHealth();
    
    // å‹•æ…‹æ¬Šé‡ç³»çµ±
    void updateDynamicWeights(const MotionState& motion);
    DynamicWeights getCurrentWeights();
    
    // ç‹€æ…‹ä¼°è¨ˆ
    void updatePositionEstimate(const GPSData& gps_data, const IMUData& imu_data);
    void updateOrientationEstimate(const IMUData& imu_data, const GPSData& gps_heading);
    void updateVelocityEstimate(const GPSData& gps_vel, const IMUData& imu_acc);
    
private:
    FusionConfig config_;
    NavigationState nav_state_;
    DynamicWeights weights_;
    FusionHealth health_;
    
    // å¡çˆ¾æ›¼æ¿¾æ³¢å™¨
    std::unique_ptr<ExtendedKalmanFilter> ekf_position_;
    std::unique_ptr<ExtendedKalmanFilter> ekf_orientation_;
    
    // è³‡æ–™å“è³ªè©•ä¼°
    float assessGPSQuality(const GPSData& gps_data);
    float assessIMUQuality(const IMUData& imu_data);
    bool isDataSynchronized(const SensorDataPacket& data);
    
    // èåˆç®—æ³•
    void performGNSSAHRSFusion();
    void applyDynamicWeights();
    void updateCovariance();
};
```

### 4. SafetyGuardian - å®‰å…¨å®ˆè­·
**è·è²¬**: ç³»çµ±å®‰å…¨ç›£æ§å’Œæ•…éšœæ¢å¾©

```cpp
class SafetyGuardian {
public:
    enum SafetyLevel {
        SAFETY_NORMAL = 0,
        SAFETY_WARNING = 1,
        SAFETY_CRITICAL = 2,
        SAFETY_EMERGENCY = 3
    };
    
    enum FaultType {
        FAULT_SENSOR_TIMEOUT,
        FAULT_DATA_INVALID,
        FAULT_COMMUNICATION_ERROR,
        FAULT_SYSTEM_OVERLOAD,
        FAULT_HARDWARE_FAILURE
    };
    
    bool initialize();
    SafetyLevel checkSystemSafety();
    bool validateSensorData(const SensorDataPacket& data);
    void handleFault(FaultType fault, const std::string& description);
    
    // ç›£æ§åŠŸèƒ½
    bool checkDataIntegrity(const SensorDataPacket& data);
    bool checkTimingConstraints();
    bool checkResourceUsage();
    
    // æ•…éšœè™•ç†
    void triggerSafeMode();
    bool attemptRecovery(FaultType fault);
    void logSafetyEvent(SafetyLevel level, const std::string& event);
    
    SafetyStatus getSafetyStatus();
    
private:
    struct SafetyConfig {
        uint32_t sensor_timeout_ms = 1000;
        float max_cpu_usage_percent = 90.0f;
        uint32_t max_memory_usage_bytes = 3072;  // 3KB
        uint8_t max_consecutive_errors = 5;
    };
    
    SafetyConfig config_;
    SafetyStatus status_;
    FaultHistory fault_history_;
    
    // è³‡æ–™é©—è­‰
    bool validateGPSData(const GPSData& gps);
    bool validateIMUData(const IMUData& imu);
    bool validateTimestamp(uint64_t timestamp);
    bool validateRange(float value, float min, float max);
    
    // ç³»çµ±ç›£æ§
    void monitorSystemHealth();
    void checkMemoryUsage();
    void checkCPUUsage();
    void checkCommunicationHealth();
};
```

## ğŸ”„ è³‡æ–™æµç¨‹æ¶æ§‹

### è³‡æ–™è™•ç†ç®¡é“
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Sensor    â”‚â”€â”€â”€â–ºâ”‚   Comm      â”‚â”€â”€â”€â–ºâ”‚   Safety    â”‚
â”‚   Hardware  â”‚    â”‚  Manager    â”‚    â”‚  Guardian   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MAVLink    â”‚â—„â”€â”€â”€â”‚   Fusion    â”‚â—„â”€â”€â”€â”‚    Data     â”‚
â”‚   Output    â”‚    â”‚   Engine    â”‚    â”‚  Processor  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è³‡æ–™é¡å‹å®šç¾©
```cpp
// data_types.h
struct SensorDataPacket {
    uint64_t timestamp_us;
    IMUData imu_data;
    GPSData gps_data;
    bool has_imu_data;
    bool has_gps_data;
    DataQuality quality;
};

struct IMUData {
    Quaternion orientation;     // å››å…ƒæ•¸
    Vector3f angular_velocity;  // è§’é€Ÿåº¦
    Vector3f acceleration;      // åŠ é€Ÿåº¦
    Vector3f magnetic_field;    // ç£å ´
    float temperature;          // æº«åº¦
    uint8_t status_flags;       // ç‹€æ…‹æ¨™èªŒ
};

struct GPSData {
    double latitude;            // ç·¯åº¦
    double longitude;           // ç¶“åº¦  
    float altitude;             // é«˜åº¦
    Vector3f velocity;          // é€Ÿåº¦
    float heading;              // èˆªå‘
    uint8_t satellites_used;    // è¡›æ˜Ÿæ•¸é‡
    float hdop;                 // æ°´å¹³ç²¾åº¦å› å­
    GPSQuality quality;         // GPS å“è³ª
};

struct NavigationState {
    // ä½ç½®
    Vector3d position_enu;      // ENU åº§æ¨™ä½ç½®
    LLHPosition position_llh;   // ç¶“ç·¯é«˜ä½ç½®
    
    // å§¿æ…‹
    Quaternion orientation;     // å››å…ƒæ•¸å§¿æ…‹
    EulerAngles euler_angles;   // æ­æ‹‰è§’
    
    // é€Ÿåº¦
    Vector3f velocity_enu;      // ENU åº§æ¨™é€Ÿåº¦
    Vector3f angular_velocity;  // è§’é€Ÿåº¦
    
    // å“è³ªæŒ‡æ¨™
    PositionAccuracy pos_accuracy;
    OrientationAccuracy ori_accuracy;
    uint64_t timestamp_us;
};
```

## âš¡ æ€§èƒ½å„ªåŒ–è¨­è¨ˆ

### 1. è¨˜æ†¶é«”ç®¡ç†å„ªåŒ–
```cpp
class MemoryManager {
public:
    // è¨˜æ†¶é«”æ± ç®¡ç†
    template<typename T>
    T* allocate() {
        return memory_pool_.allocate<T>();
    }
    
    template<typename T>  
    void deallocate(T* ptr) {
        memory_pool_.deallocate(ptr);
    }
    
    // è¨˜æ†¶é«”ä½¿ç”¨ç›£æ§
    size_t getTotalUsage();
    size_t getAvailableMemory();
    float getFragmentationRatio();
    
private:
    StaticMemoryPool memory_pool_;
    std::array<uint8_t, 4096> memory_buffer_;
};
```

### 2. CPU è² è¼‰å„ªåŒ–
```cpp
// ä»»å‹™èª¿åº¦å„ªåŒ–
class TaskScheduler {
public:
    enum TaskPriority {
        PRIORITY_CRITICAL = 0,  // èåˆå¼•æ“
        PRIORITY_HIGH = 1,      // é€šè¨Šè™•ç†
        PRIORITY_MEDIUM = 2,    // è³‡æ–™è™•ç†  
        PRIORITY_LOW = 3        // æ—¥èªŒã€çµ±è¨ˆ
    };
    
    void scheduleTask(std::function<void()> task, TaskPriority priority);
    void executeTasks();
    void optimizeScheduling();
    
private:
    std::array<std::queue<Task>, 4> task_queues_;
    uint32_t execution_budget_us_[4] = {2000, 1500, 1000, 500};
};
```

### 3. é€šè¨Šå„ªåŒ–
```cpp
// æ™ºèƒ½ç·©è¡ç®¡ç†
class SmartBuffer {
public:
    bool write(const uint8_t* data, size_t size);
    size_t read(uint8_t* buffer, size_t max_size);
    
    // è‡ªé©æ‡‰ç·©è¡å¤§å°
    void adjustBufferSize(float utilization_rate);
    void compactBuffer();
    
    size_t getUsedSize() const;
    size_t getAvailableSize() const;
    float getUtilizationRate() const;
    
private:
    std::vector<uint8_t> buffer_;
    size_t read_pos_;
    size_t write_pos_;
    size_t max_size_;
};
```

## ğŸ”§ éŒ¯èª¤è™•ç†æ¶æ§‹

### å¤šå±¤æ¬¡éŒ¯èª¤è™•ç†
```cpp
class ErrorHandler {
public:
    enum ErrorLevel {
        ERROR_INFO,      // è³‡è¨Šæ€§éŒ¯èª¤
        ERROR_WARNING,   // è­¦å‘Šæ€§éŒ¯èª¤
        ERROR_CRITICAL,  // åš´é‡éŒ¯èª¤
        ERROR_FATAL      // è‡´å‘½éŒ¯èª¤
    };
    
    enum RecoveryStrategy {
        RECOVERY_IGNORE,
        RECOVERY_RETRY,
        RECOVERY_RESET_MODULE,
        RECOVERY_SAFE_MODE,
        RECOVERY_SYSTEM_RESTART
    };
    
    void reportError(ErrorLevel level, ErrorCode code, const std::string& description);
    bool handleError(ErrorCode code);
    RecoveryStrategy getRecoveryStrategy(ErrorCode code);
    
private:
    std::map<ErrorCode, RecoveryStrategy> recovery_strategies_;
    ErrorStatistics error_stats_;
    
    void executeRecovery(ErrorCode code, RecoveryStrategy strategy);
    void logError(const ErrorRecord& error);
    void updateErrorStatistics(ErrorCode code);
};
```

## ğŸ”— ç›¸é—œæ–‡ä»¶é€£çµ

### è©³ç´°è¨­è¨ˆæ–‡ä»¶
- [[4.æºä»£ç¢¼æ¶æ§‹/æ ¸å¿ƒæ¨¡çµ„è¨­è¨ˆ]] - å„æ ¸å¿ƒæ¨¡çµ„è©³ç´°è¨­è¨ˆ
- [[4.æºä»£ç¢¼æ¶æ§‹/é€šè¨Šæ¨¡çµ„è¨­è¨ˆ]] - é€šè¨Šç³»çµ±å¯¦ä½œç´°ç¯€
- [[4.æºä»£ç¢¼æ¶æ§‹/èåˆæ¼”ç®—æ³•æ¨¡çµ„è¨­è¨ˆ]] - èåˆå¼•æ“æ¼”ç®—æ³•è¨­è¨ˆ

### å¯¦ä½œæŒ‡å°
- [[5.å¯¦ä½œæŒ‡å°/ç·¨ç¢¼è¦ç¯„]] - ä»£ç¢¼é¢¨æ ¼å’Œé–‹ç™¼æ¨™æº–
- [[5.å¯¦ä½œæŒ‡å°/æ¸¬è©¦ç­–ç•¥]] - æ¸¬è©¦æ–¹æ³•å’Œå“è³ªä¿è­‰
- [[3.è»Ÿé«”æ¶æ§‹é‡æ–°è¨­è¨ˆ/æ¨¡çµ„åŒ–è¨­è¨ˆæ–¹é‡]] - æ¨¡çµ„åŒ–å¯¦ä½œæº–å‰‡

### ç¡¬é«”ç›¸é—œ
- [[2.ç¡¬é«”æ¶æ§‹/ç¡¬é«”æ¶æ§‹æ•´åˆæ–‡ä»¶]] - ç¡¬é«”æ¶æ§‹èªªæ˜
- [[2.ç¡¬é«”æ¶æ§‹/UARTé…ç½®èªªæ˜]] - ç¡¬é«”é€šè¨Šé…ç½®

---

**æœ€å¾Œæ›´æ–°**: 2025-08-08  
**é©ç”¨ç‰ˆæœ¬**: GMINS v2.0  
**ç¶­è­·è€…**: GMINS é–‹ç™¼åœ˜éšŠ  
**è¨­è¨ˆç‹€æ…‹**: æ¶æ§‹è¨­è¨ˆå®Œæˆï¼Œæº–å‚™è©³ç´°å¯¦ä½œ
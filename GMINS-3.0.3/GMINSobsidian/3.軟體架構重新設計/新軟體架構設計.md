# 新軟體架構設計

> **功能**: GMINS v2.0 軟體架構完整重新設計說明  
> **版本**: v2.0  
> **最後更新**: 2025-08-08  
> **設計理念**: 模組化、可維護、高效能

## 🎯 設計目標與改進

### 從 MINSPixhawk 到 GMINS 的進化
GMINS v2.0 基於 MINSPixhawk 的實戰經驗，進行完全的軟體架構重新設計，解決原有架構的問題並提升整體性能。

#### 原有架構問題分析
1. **代碼組織混亂**: 功能模組混雜，難以維護
2. **耦合度過高**: 模組間依賴複雜，修改影響範圍大  
3. **錯誤處理不完善**: 缺乏系統性的錯誤恢復機制
4. **資源使用效率低**: 記憶體和CPU使用未優化
5. **測試困難**: 缺乏獨立可測試的模組設計

#### GMINS v2.0 改進目標
1. **模組化設計**: 清晰的功能分離和標準介面
2. **低耦合高內聚**: 模組間依賴最小化  
3. **完善的錯誤處理**: 多層次錯誤檢測和自動恢復
4. **資源優化**: 高效的記憶體和CPU資源使用
5. **可測試性**: 每個模組都可獨立測試和驗證
6. **方便除錯開關**

- 每個模組都可以有自己的 `#define GNSS_DEBUG`、`#define IMU_DEBUG` 或使用全域 log 系統的**分類開關**。
    
- 你可以單獨打開某個模組的 log，而不會被其他模組洗版。

## 🏗️ 整體架構設計

### 系統層次架構
```
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                        │
│                   (Arduino Main Loop)                      │
├─────────────────────────────────────────────────────────────┤
│                     Core Services                          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   System    │ │   Fusion    │ │   Safety    │          │
│  │ Controller  │ │   Engine    │ │  Guardian   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
├─────────────────────────────────────────────────────────────┤
│                  Communication Layer                       │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │    Comm     │ │   MAVLink   │ │    XBUS     │          │
│  │   Manager   │ │   Handler   │ │   Handler   │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
│                         ┌─────────────┐                    │
│                         │    NMEA     │                    │
│                         │   Handler   │                    │
│                         └─────────────┘                    │
├─────────────────────────────────────────────────────────────┤
│                    Data Processing Layer                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │    Data     │ │ Coordinate  │ │   Sensor    │          │
│  │  Processor  │ │ Transform   │ │   Fusion    │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
├─────────────────────────────────────────────────────────────┤
│                     Utility Layer                          │
│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐            │
│  │Logger│ │Config│ │Math  │ │Time  │ │Memory│            │
│  │      │ │ Mgr  │ │Utils │ │Utils │ │ Mgr  │            │
│  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘            │
├─────────────────────────────────────────────────────────────┤
│                Hardware Abstraction Layer                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │    UART     │ │   Pin Def   │ │   Board     │          │
│  │ Interface   │ │             │ │  Support    │          │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

## 🔧 核心架構組件

### 1. SystemController - 系統控制器
**職責**: 系統生命週期管理和協調各模組運作

```cpp
class SystemController {
public:
    // 生命週期管理
    enum SystemState {
        STATE_INITIALIZING,
        STATE_READY,
        STATE_RUNNING,
        STATE_ERROR,
        STATE_SHUTDOWN
    };
    
    // 運作模式
    enum OperationMode {
        MODE_STARTUP,       // 啟動模式
        MODE_NORMAL,        // 正常運作
        MODE_DEBUG,         // 調試模式  
        MODE_SAFE,          // 安全模式
        MODE_MAINTENANCE    // 維護模式
    };
    
    // 核心介面
    bool initialize();
    void run();                    // 主要執行循環
    void shutdown();
    bool setMode(OperationMode mode);
    SystemState getState() const;
    SystemHealth getHealthStatus();
    
private:
    void initializeSubsystems();
    void coordinateModules();
    void handleStateTransitions();
    void performHealthCheck();
    
    SystemState current_state_;
    OperationMode current_mode_;
    std::unique_ptr<CommunicationManager> comm_manager_;
    std::unique_ptr<FusionEngine> fusion_engine_;
    std::unique_ptr<SafetyGuardian> safety_guardian_;
    std::unique_ptr<DataProcessor> data_processor_;
};
```

### 2. CommunicationManager - 通訊管理器
**職責**: 統一管理所有硬體通訊介面

```cpp
class CommunicationManager {
public:
    enum ChannelId {
        CHANNEL_PIXHAWK = 0,    // Serial1 - MAVLink
        CHANNEL_MTI680 = 1,     // Serial2 - XBUS
        CHANNEL_NMEA_OUT = 2,   // Serial3 - NMEA Output
        CHANNEL_NMEA_IN = 3,    // Serial4 - NMEA Input
        CHANNEL_COUNT = 4
    };
    
    bool initialize();
    void processIncomingData();
    bool sendData(ChannelId channel, const uint8_t* data, size_t size);
    
    // 狀態監控
    CommChannelStats getChannelStats(ChannelId channel);
    bool isChannelHealthy(ChannelId channel);
    void resetChannel(ChannelId channel);
    
    // 錯誤處理
    void handleCommunicationError(ChannelId channel, CommError error);
    bool recoverFromError(ChannelId channel);
    
private:
    struct CommChannel {
        std::unique_ptr<UARTInterface> uart;
        uint32_t baud_rate;
        bool is_active;
        CommChannelStats stats;
        std::queue<uint8_t> rx_buffer;
        std::queue<uint8_t> tx_buffer;
    };
    
    std::array<CommChannel, CHANNEL_COUNT> channels_;
    std::unique_ptr<MAVLinkHandler> mavlink_handler_;
    std::unique_ptr<XBUSHandler> xbus_handler_;
    std::unique_ptr<NMEAHandler> nmea_handler_;
    
    void processChannelData(ChannelId channel);
    void updateChannelStats(ChannelId channel);
    bool validateChannelHealth(ChannelId channel);
};
```

### 3. FusionEngine - 融合引擎  
**職責**: 多感測器資料融合和狀態估計

```cpp
class FusionEngine {
public:
    struct FusionConfig {
        // 動態權重配置
        float base_trust_factor = 0.1f;
        float max_trust_factor = 1.0f;
        float trust_decay_rate = 0.95f;
        
        // 融合參數
        float position_weight_gnss = 0.7f;
        float position_weight_imu = 0.3f;
        float orientation_weight_gnss = 0.3f;
        float orientation_weight_imu = 0.7f;
        
        // 時間同步
        uint32_t max_time_diff_us = 50000;  // 50ms
        bool enable_time_sync = true;
    };
    
    bool initialize(const FusionConfig& config);
    void processSensorData(const SensorDataPacket& data);
    NavigationState getNavigationState();
    FusionHealth getFusionHealth();
    
    // 動態權重系統
    void updateDynamicWeights(const MotionState& motion);
    DynamicWeights getCurrentWeights();
    
    // 狀態估計
    void updatePositionEstimate(const GPSData& gps_data, const IMUData& imu_data);
    void updateOrientationEstimate(const IMUData& imu_data, const GPSData& gps_heading);
    void updateVelocityEstimate(const GPSData& gps_vel, const IMUData& imu_acc);
    
private:
    FusionConfig config_;
    NavigationState nav_state_;
    DynamicWeights weights_;
    FusionHealth health_;
    
    // 卡爾曼濾波器
    std::unique_ptr<ExtendedKalmanFilter> ekf_position_;
    std::unique_ptr<ExtendedKalmanFilter> ekf_orientation_;
    
    // 資料品質評估
    float assessGPSQuality(const GPSData& gps_data);
    float assessIMUQuality(const IMUData& imu_data);
    bool isDataSynchronized(const SensorDataPacket& data);
    
    // 融合算法
    void performGNSSAHRSFusion();
    void applyDynamicWeights();
    void updateCovariance();
};
```

### 4. SafetyGuardian - 安全守護
**職責**: 系統安全監控和故障恢復

```cpp
class SafetyGuardian {
public:
    enum SafetyLevel {
        SAFETY_NORMAL = 0,
        SAFETY_WARNING = 1,
        SAFETY_CRITICAL = 2,
        SAFETY_EMERGENCY = 3
    };
    
    enum FaultType {
        FAULT_SENSOR_TIMEOUT,
        FAULT_DATA_INVALID,
        FAULT_COMMUNICATION_ERROR,
        FAULT_SYSTEM_OVERLOAD,
        FAULT_HARDWARE_FAILURE
    };
    
    bool initialize();
    SafetyLevel checkSystemSafety();
    bool validateSensorData(const SensorDataPacket& data);
    void handleFault(FaultType fault, const std::string& description);
    
    // 監控功能
    bool checkDataIntegrity(const SensorDataPacket& data);
    bool checkTimingConstraints();
    bool checkResourceUsage();
    
    // 故障處理
    void triggerSafeMode();
    bool attemptRecovery(FaultType fault);
    void logSafetyEvent(SafetyLevel level, const std::string& event);
    
    SafetyStatus getSafetyStatus();
    
private:
    struct SafetyConfig {
        uint32_t sensor_timeout_ms = 1000;
        float max_cpu_usage_percent = 90.0f;
        uint32_t max_memory_usage_bytes = 3072;  // 3KB
        uint8_t max_consecutive_errors = 5;
    };
    
    SafetyConfig config_;
    SafetyStatus status_;
    FaultHistory fault_history_;
    
    // 資料驗證
    bool validateGPSData(const GPSData& gps);
    bool validateIMUData(const IMUData& imu);
    bool validateTimestamp(uint64_t timestamp);
    bool validateRange(float value, float min, float max);
    
    // 系統監控
    void monitorSystemHealth();
    void checkMemoryUsage();
    void checkCPUUsage();
    void checkCommunicationHealth();
};
```

## 🔄 資料流程架構

### 資料處理管道
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Sensor    │───►│   Comm      │───►│   Safety    │
│   Hardware  │    │  Manager    │    │  Guardian   │
└─────────────┘    └─────────────┘    └─────────────┘
                                             │
                                             ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  MAVLink    │◄───│   Fusion    │◄───│    Data     │
│   Output    │    │   Engine    │    │  Processor  │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 資料類型定義
```cpp
// data_types.h
struct SensorDataPacket {
    uint64_t timestamp_us;
    IMUData imu_data;
    GPSData gps_data;
    bool has_imu_data;
    bool has_gps_data;
    DataQuality quality;
};

struct IMUData {
    Quaternion orientation;     // 四元數
    Vector3f angular_velocity;  // 角速度
    Vector3f acceleration;      // 加速度
    Vector3f magnetic_field;    // 磁場
    float temperature;          // 溫度
    uint8_t status_flags;       // 狀態標誌
};

struct GPSData {
    double latitude;            // 緯度
    double longitude;           // 經度  
    float altitude;             // 高度
    Vector3f velocity;          // 速度
    float heading;              // 航向
    uint8_t satellites_used;    // 衛星數量
    float hdop;                 // 水平精度因子
    GPSQuality quality;         // GPS 品質
};

struct NavigationState {
    // 位置
    Vector3d position_enu;      // ENU 座標位置
    LLHPosition position_llh;   // 經緯高位置
    
    // 姿態
    Quaternion orientation;     // 四元數姿態
    EulerAngles euler_angles;   // 歐拉角
    
    // 速度
    Vector3f velocity_enu;      // ENU 座標速度
    Vector3f angular_velocity;  // 角速度
    
    // 品質指標
    PositionAccuracy pos_accuracy;
    OrientationAccuracy ori_accuracy;
    uint64_t timestamp_us;
};
```

## ⚡ 性能優化設計

### 1. 記憶體管理優化
```cpp
class MemoryManager {
public:
    // 記憶體池管理
    template<typename T>
    T* allocate() {
        return memory_pool_.allocate<T>();
    }
    
    template<typename T>  
    void deallocate(T* ptr) {
        memory_pool_.deallocate(ptr);
    }
    
    // 記憶體使用監控
    size_t getTotalUsage();
    size_t getAvailableMemory();
    float getFragmentationRatio();
    
private:
    StaticMemoryPool memory_pool_;
    std::array<uint8_t, 4096> memory_buffer_;
};
```

### 2. CPU 負載優化
```cpp
// 任務調度優化
class TaskScheduler {
public:
    enum TaskPriority {
        PRIORITY_CRITICAL = 0,  // 融合引擎
        PRIORITY_HIGH = 1,      // 通訊處理
        PRIORITY_MEDIUM = 2,    // 資料處理  
        PRIORITY_LOW = 3        // 日誌、統計
    };
    
    void scheduleTask(std::function<void()> task, TaskPriority priority);
    void executeTasks();
    void optimizeScheduling();
    
private:
    std::array<std::queue<Task>, 4> task_queues_;
    uint32_t execution_budget_us_[4] = {2000, 1500, 1000, 500};
};
```

### 3. 通訊優化
```cpp
// 智能緩衝管理
class SmartBuffer {
public:
    bool write(const uint8_t* data, size_t size);
    size_t read(uint8_t* buffer, size_t max_size);
    
    // 自適應緩衝大小
    void adjustBufferSize(float utilization_rate);
    void compactBuffer();
    
    size_t getUsedSize() const;
    size_t getAvailableSize() const;
    float getUtilizationRate() const;
    
private:
    std::vector<uint8_t> buffer_;
    size_t read_pos_;
    size_t write_pos_;
    size_t max_size_;
};
```

## 🔧 錯誤處理架構

### 多層次錯誤處理
```cpp
class ErrorHandler {
public:
    enum ErrorLevel {
        ERROR_INFO,      // 資訊性錯誤
        ERROR_WARNING,   // 警告性錯誤
        ERROR_CRITICAL,  // 嚴重錯誤
        ERROR_FATAL      // 致命錯誤
    };
    
    enum RecoveryStrategy {
        RECOVERY_IGNORE,
        RECOVERY_RETRY,
        RECOVERY_RESET_MODULE,
        RECOVERY_SAFE_MODE,
        RECOVERY_SYSTEM_RESTART
    };
    
    void reportError(ErrorLevel level, ErrorCode code, const std::string& description);
    bool handleError(ErrorCode code);
    RecoveryStrategy getRecoveryStrategy(ErrorCode code);
    
private:
    std::map<ErrorCode, RecoveryStrategy> recovery_strategies_;
    ErrorStatistics error_stats_;
    
    void executeRecovery(ErrorCode code, RecoveryStrategy strategy);
    void logError(const ErrorRecord& error);
    void updateErrorStatistics(ErrorCode code);
};
```

## 🔗 相關文件連結

### 詳細設計文件
- [[4.源代碼架構/核心模組設計]] - 各核心模組詳細設計
- [[4.源代碼架構/通訊模組設計]] - 通訊系統實作細節
- [[4.源代碼架構/融合演算法模組設計]] - 融合引擎演算法設計

### 實作指導
- [[5.實作指導/編碼規範]] - 代碼風格和開發標準
- [[5.實作指導/測試策略]] - 測試方法和品質保證
- [[3.軟體架構重新設計/模組化設計方針]] - 模組化實作準則

### 硬體相關
- [[2.硬體架構/硬體架構整合文件]] - 硬體架構說明
- [[2.硬體架構/UART配置說明]] - 硬體通訊配置

---

**最後更新**: 2025-08-08  
**適用版本**: GMINS v2.0  
**維護者**: GMINS 開發團隊  
**設計狀態**: 架構設計完成，準備詳細實作